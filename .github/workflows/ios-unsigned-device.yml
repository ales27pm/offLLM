# yamllint disable rule:line-length
name: iOS unsigned device build

on:
  push:
    branches: [main, master]
  pull_request:
    branches: [main, master]

env:
  XCODE_VERSION: "16.4"

jobs:
  archive-ipa:
    name: Archive (device) & make unsigned IPA
    runs-on: macos-15
    env:
      SCHEME: monGARS
      DERIVED_DATA: ${{ github.workspace }}/build/DerivedData
      OUTPUT_DIR: build/output

    steps:
      - uses: actions/checkout@ff7abcd0c3c05ccf6adc123a8cd1fd4fb30fb493

      - name: Select Xcode
        uses: maxim-lobanov/setup-xcode@60606e260d2fc5762a71e64e74b2174e8ea3c8bd
        with:
          xcode-version: ${{ env.XCODE_VERSION }}

      - uses: actions/setup-node@cd2651c46231bc0d6f48d6b34433b845331235fe
        with:
          node-version: 20
          cache: npm

      - name: Set up Ruby (3.2) with bundler cache
        uses: ruby/setup-ruby@44511735964dcb71245e7e55f72539531f7bc0eb
        with:
          ruby-version: "3.2"
          bundler-cache: true
          working-directory: ios

      - name: Cache CocoaPods
        uses: actions/cache@0400d5f644dc74513175e3cd8d07132dd4860809
        with:
          path: |
            ~/.cocoapods
            ios/Pods
          key: ${{ runner.os }}-pods-xcode-${{ env.XCODE_VERSION }}-${{ hashFiles('ios/Podfile.lock') }}
          restore-keys: |
            ${{ runner.os }}-pods-xcode-${{ env.XCODE_VERSION }}-
            ${{ runner.os }}-pods-

      - name: Clean DerivedData & SPM cache
        run: |
          rm -rf "$DERIVED_DATA" ~/Library/Developer/Xcode/DerivedData
          rm -rf "$HOME/Library/Developer/Xcode/DerivedData/SourcePackages"

      - name: Run JS checks (tests, lint, format)
        run: |
          npm ci
          npm test
          npm run lint
          npm run format:check

      - name: Validate patch-package patches
        run: npx --yes patch-package --check

      - name: Install XcodeGen (if needed)
        run: |
          if ! command -v xcodegen >/dev/null 2>&1; then
            brew update
            brew install xcodegen
          fi

      - name: Generate Xcode project (XcodeGen)
        working-directory: ios
        run: xcodegen generate

      - name: Run codegen
        run: npm run codegen

      - name: Bundle install (ios/)
        working-directory: ios
        run: |
          bundle config set path 'vendor/bundle'
          bundle install --jobs 4

      - name: CocoaPods install
        working-directory: ios
        env:
          COCOAPODS_DISABLE_STATS: "true"
        run: bundle exec pod install

      - name: Capture iOS environment diagnostics
        run: |
          #!/usr/bin/env bash
          set -euo pipefail
          mkdir -p build/diagnostics
          LOG="build/diagnostics/environment.log"
          {
            echo "Collected at (UTC): $(date -u +\"%Y-%m-%dT%H:%M:%SZ\")"
            echo "Runner name: ${RUNNER_NAME:-unknown}"
            echo "Runner OS: ${RUNNER_OS:-unknown}"
            echo "Runner image: ${ImageOS:-unknown} ${ImageVersion:-unknown}"
            echo
            echo "## macOS"
            if command -v sw_vers >/dev/null 2>&1; then
              sw_vers
            else
              echo "sw_vers unavailable"
            fi
            echo
            echo "## Xcode"
            if command -v xcode-select >/dev/null 2>&1; then
              echo "xcode-select: $(xcode-select -p)"
            else
              echo "xcode-select not found"
            fi
            if command -v xcodebuild >/dev/null 2>&1; then
              xcodebuild -version || true
              xcodebuild -showsdks || true
            else
              echo "xcodebuild unavailable"
            fi
            echo
            echo "## Tool versions"
            if command -v xcodegen >/dev/null 2>&1; then
              echo "xcodegen: $(xcodegen --version)"
            else
              echo "xcodegen: unavailable"
            fi
            if command -v swift >/dev/null 2>&1; then
              swift --version || true
            else
              echo "swift: unavailable"
            fi
            if command -v clang >/dev/null 2>&1; then
              clang --version | head -n 1 || true
            else
              echo "clang: unavailable"
            fi
            if command -v ruby >/dev/null 2>&1; then
              echo "ruby: $(ruby --version)"
            else
              echo "ruby: unavailable"
            fi
            if command -v bundle >/dev/null 2>&1; then
              echo "bundler: $(bundle --version)"
            else
              echo "bundler: unavailable"
            fi
            if command -v pod >/dev/null 2>&1; then
              echo "cocoapods: $(pod --version)"
            else
              echo "cocoapods: unavailable"
            fi
            if command -v node >/dev/null 2>&1; then
              echo "node: $(node --version)"
            else
              echo "node: unavailable"
            fi
            if command -v npm >/dev/null 2>&1; then
              echo "npm: $(npm --version)"
            else
              echo "npm: unavailable"
            fi
            if command -v python3 >/dev/null 2>&1; then
              echo "python3: $(python3 --version)"
            else
              echo "python3: unavailable"
            fi
          } | tee "$LOG"

          (
            cd ios
            if command -v bundle >/dev/null 2>&1; then
              bundle env > ../build/diagnostics/bundle-env.log 2>&1 || true
              bundle exec pod --version > ../build/diagnostics/pod-version.log 2>&1 || true
              bundle exec pod env > ../build/diagnostics/pod-env.log 2>&1 || true
            fi
          ) || true

      - name: Detect Xcode container
        working-directory: ios
        run: |
          set -euo pipefail
          CONTAINER="$(/usr/bin/find . -maxdepth 1 -name '*.xcworkspace' -print -quit)"
          TYPE="workspace"
          if [ -z "$CONTAINER" ]; then
            CONTAINER="$(/usr/bin/find . -maxdepth 1 -name '*.xcodeproj' -print -quit)"
            TYPE="project"
          fi
          if [ -z "$CONTAINER" ]; then
            echo "::error title=No Xcode container::No ios/*.xcworkspace or ios/*.xcodeproj found"
            exit 1
          fi
          CONTAINER="${CONTAINER#./}"
          echo "XCODE_CONTAINER=$(pwd)/$CONTAINER" >> "$GITHUB_ENV"
          echo "XCODE_CONTAINER_TYPE=$TYPE" >> "$GITHUB_ENV"

      - name: Snapshot Xcode project metadata
        run: |
          #!/usr/bin/env bash
          set -euo pipefail
          mkdir -p build/diagnostics
          if [ -z "${XCODE_CONTAINER:-}" ] || [ -z "${XCODE_CONTAINER_TYPE:-}" ]; then
            echo "Xcode container metadata unavailable" > build/diagnostics/xcodebuild-metadata.log
            exit 0
          fi
          FLAG="-${XCODE_CONTAINER_TYPE}"
          xcodebuild "$FLAG" "$XCODE_CONTAINER" -list -json \
            > build/diagnostics/xcodebuild-list.json 2> build/diagnostics/xcodebuild-list.stderr || true
          xcodebuild "$FLAG" "$XCODE_CONTAINER" -list \
            > build/diagnostics/xcodebuild-list.txt 2>&1 || true
          xcodebuild "$FLAG" "$XCODE_CONTAINER" -scheme "$SCHEME" -showBuildSettings \
            > build/diagnostics/build-settings.log 2>&1 || true
          if [ -s build/diagnostics/xcodebuild-list.stderr ]; then
            printf '\n(list -json stderr)\n' >> build/diagnostics/xcodebuild-list.txt
            cat build/diagnostics/xcodebuild-list.stderr >> build/diagnostics/xcodebuild-list.txt || true
          fi
          rm -f build/diagnostics/xcodebuild-list.stderr

      - name: iOS Doctor (workspace must exist)
        if: ${{ env.XCODE_CONTAINER_TYPE == 'workspace' }}
        run: |
          chmod +x scripts/ios_doctor.sh || true
          ./scripts/ios_doctor.sh

      - name: Resolve SwiftPM packages (fail fast)
        run: |
          set -euxo pipefail
          RB="$DERIVED_DATA/ResultBundle.xcresult"
          rm -rf "$RB"
          mkdir -p "$DERIVED_DATA"
          xcodebuild -resolvePackageDependencies \
            -${XCODE_CONTAINER_TYPE} "$XCODE_CONTAINER" \
            -scheme "$SCHEME" \
            -clonedSourcePackagesDirPath "$DERIVED_DATA/SourcePackages" \
            -derivedDataPath "$DERIVED_DATA" \
            -resultBundlePath "$RB"
          RESOLVE_RESULT_BUNDLE=""
          if [ -d "$RB" ]; then
            RESOLVE_RESULT_BUNDLE="$RB"
          fi
          SEARCH_ROOTS=("$DERIVED_DATA/Logs" "$HOME/Library/Developer/Xcode/DerivedData")
          for root in "${SEARCH_ROOTS[@]}"; do
            if [ -d "$root" ]; then
              while IFS= read -r candidate; do
                if [ -d "$candidate" ]; then
                  if [ -z "$RESOLVE_RESULT_BUNDLE" ]; then
                    RESOLVE_RESULT_BUNDLE="$candidate"
                  else
                    BEST_MTIME="$(stat -f %m "$RESOLVE_RESULT_BUNDLE")"
                    CANDIDATE_MTIME="$(stat -f %m "$candidate")"
                    if [ "$CANDIDATE_MTIME" -gt "$BEST_MTIME" ]; then
                      RESOLVE_RESULT_BUNDLE="$candidate"
                    fi
                  fi
                fi
              done < <(find "$root" -type d -path '*/Logs/Resolve*.xcresult')
            fi
          done
          if [ -n "$RESOLVE_RESULT_BUNDLE" ]; then
            echo "Using resolve bundle at $RESOLVE_RESULT_BUNDLE"
            echo "RESOLVE_RESULT_BUNDLE=$RESOLVE_RESULT_BUNDLE" >> "$GITHUB_ENV"
          fi

      - name: Export resolve-package xcresult JSON
        if: ${{ always() }}
        run: |
          # Avoid 'set -x' to prevent exposing secrets in logs
          set -euo pipefail
          RB="${RESOLVE_RESULT_BUNDLE:-$DERIVED_DATA/ResultBundle.xcresult}"
          mkdir -p build
          if [ -d "$RB" ]; then
            # Attempt to export as JSON (legacy path first, then object path)
            if ! xcrun xcresulttool get --legacy --path "$RB" --format json > build/ResultBundle_resolve.json 2>build/xcresulttool_error.log; then
              echo "::warning title=xcresulttool legacy export failed::See build/xcresulttool_error.log for details"
              cat build/xcresulttool_error.log
              xcrun xcresulttool get object --path "$RB" --format json > build/ResultBundle_resolve.json
            fi
          else
            ts="$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
            printf '{\n  "notice": "Resolve result bundle missing",\n  "generatedAt": "%s",\n  "searched": [\n    "%s",\n    "%s",\n    "%s"\n  ]\n}\n' \
              "$ts" \
              "${DERIVED_DATA}/ResultBundle.xcresult" \
              "${DERIVED_DATA}/Logs" \
              "${HOME}/Library/Developer/Xcode/DerivedData" \
              > build/ResultBundle_resolve.json
            echo "::notice title=Resolve xcresult missing::No resolve-result xcresult produced (stub JSON emitted)"
          fi

      - name: Ensure resolve xcresult JSON artifact
        if: ${{ always() }}
        run: |
          set -euo pipefail
          mkdir -p build
          if [ ! -f build/ResultBundle_resolve.json ]; then
            ts="$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
            printf '{\n  "notice": "Resolve result bundle not generated",\n  "generatedAt": "%s"\n}\n' "$ts" \
              > build/ResultBundle_resolve.json
          fi

      - name: Check for iOS Device SDK
        id: sdk
        run: |
          if xcodebuild -showsdks | grep -q "iphoneos"; then
            echo "present=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Archive (device) — stop on errors
        if: ${{ steps.sdk.outputs.present == 'true' }}
        env:
          RB_ARCHIVE: ${{ env.DERIVED_DATA }}/ResultBundle_archive.xcresult
          ARCHIVE_PATH: ${{ env.DERIVED_DATA }}/Archive.xcarchive
        run: |
          set -euxo pipefail
          rm -rf "$ARCHIVE_PATH" "$RB_ARCHIVE"
          LOG_FILE="build-log.txt"
          rm -f "$LOG_FILE"
          xcodebuild archive \
            -${XCODE_CONTAINER_TYPE} "$XCODE_CONTAINER" \
            -scheme "$SCHEME" \
            -configuration Release \
            -destination generic/platform=iOS \
            CODE_SIGNING_ALLOWED=NO CODE_SIGNING_REQUIRED=NO \
            -derivedDataPath "$DERIVED_DATA" \
            -resultBundlePath "$RB_ARCHIVE" \
            -archivePath "$ARCHIVE_PATH" \
            2>&1 | tee "$LOG_FILE"

      - name: Collect build log
        if: ${{ always() }}
        run: |
          mkdir -p "$OUTPUT_DIR"
          if [ -f build-log.txt ]; then
            cp build-log.txt "$OUTPUT_DIR/" || true
          fi

      - name: Summarize xcodebuild log
        if: ${{ always() }}
        run: |
          python3 <<'PY'
          from pathlib import Path

          out_dir = Path("build/diagnostics")
          out_dir.mkdir(parents=True, exist_ok=True)
          log_path = Path("build-log.txt")
          summary_path = out_dir / "xcodebuild-errors.log"

          if not log_path.exists():
              summary_path.write_text("build-log.txt not found\n", encoding="utf-8")
          else:
              lines = log_path.read_text(encoding="utf-8", errors="ignore").splitlines()
              errors: list[str] = []
              warnings: list[str] = []
              for line in lines:
                  stripped = line.strip()
                  if not stripped:
                      continue
                  lower = stripped.lower()
                  if (
                      "error:" in lower
                      or lower.startswith("error ")
                      or " fatal error" in lower
                      or " build failed" in lower
                      or lower.startswith("ld: fatal error")
                  ):
                      errors.append(stripped)
                  elif (
                      " warning:" in lower
                      or lower.startswith("warning:")
                      or lower.startswith("ld: warning")
                  ):
                      warnings.append(stripped)
              tail = lines[-60:]
              with summary_path.open("w", encoding="utf-8") as handle:
                  handle.write(f"Errors ({len(errors)}):\n")
                  for entry in errors[:50]:
                      handle.write(f"- {entry}\n")
                  if len(errors) > 50:
                      handle.write(f"… (+{len(errors) - 50} more)\n")
                  handle.write("\nWarnings ({}):\n".format(len(warnings)))
                  for entry in warnings[:50]:
                      handle.write(f"- {entry}\n")
                  if len(warnings) > 50:
                      handle.write(f"… (+{len(warnings) - 50} more)\n")
                  handle.write("\nLog tail:\n")
                  for entry in tail:
                      handle.write(entry + "\n")
          PY

      - name: Catalog DerivedData logs
        if: ${{ always() }}
        run: |
          python3 <<'PY'
          import os
          import shutil
          import time
          from pathlib import Path

          out_dir = Path("build/diagnostics")
          out_dir.mkdir(parents=True, exist_ok=True)
          base = Path(os.environ.get("DERIVED_DATA", os.path.expanduser("~/Library/Developer/Xcode/DerivedData")))
          listing = out_dir / "derived-data.txt"

          if not base.exists():
              listing.write_text(f"DerivedData directory not found: {base}\n", encoding="utf-8")
          else:
              entries = sorted([p for p in base.iterdir() if p.is_dir()], key=lambda p: p.stat().st_mtime, reverse=True)
              lines: list[str] = [f"DerivedData base: {base}"]
              for entry in entries[:6]:
                  try:
                      mtime = time.strftime("%Y-%m-%d %H:%M:%SZ", time.gmtime(entry.stat().st_mtime))
                  except FileNotFoundError:
                      continue
                  lines.append(f"- {entry.name} (modified {mtime})")
                  logs_dir = entry / "Logs" / "Build"
                  if logs_dir.is_dir():
                      candidates = sorted(
                          [p for p in logs_dir.glob("*.xcactivitylog") if p.is_file()],
                          key=lambda p: p.stat().st_mtime,
                          reverse=True,
                      )
                      if candidates:
                          chosen = candidates[0]
                          size = chosen.stat().st_size
                          human_size = f"{size / (1024 * 1024):.1f} MiB"
                          if size <= 8 * 1024 * 1024:
                              target = out_dir / f"{entry.name}_{chosen.name}"
                              try:
                                  shutil.copy2(chosen, target)
                                  lines.append(f"  Copied log: {target.name} ({human_size})")
                              except Exception as exc:
                                  lines.append(f"  Failed to copy {chosen.name}: {exc}")
                          else:
                              lines.append(f"  Skipped log {chosen.name} ({human_size}) — larger than 8 MiB")
              listing.write_text("\n".join(lines) + "\n", encoding="utf-8")
          PY

      - name: Collect unified log (xcodebuild)
        if: ${{ always() }}
        run: |
          #!/usr/bin/env bash
          set -euo pipefail
          mkdir -p build/diagnostics
          if command -v log >/dev/null 2>&1; then
            if ! log show --predicate 'process == "xcodebuild"' --style compact --last 30m \
              > build/diagnostics/unified-xcodebuild.log 2> build/diagnostics/unified-xcodebuild.err; then
              {
                echo "Failed to collect unified log via 'log show'"
                cat build/diagnostics/unified-xcodebuild.err || true
              } > build/diagnostics/unified-xcodebuild.log
            fi
            rm -f build/diagnostics/unified-xcodebuild.err
          else
            echo "'log' command unavailable on this runner" > build/diagnostics/unified-xcodebuild.log
          fi

      - name: Publish diagnostics summary
        if: ${{ always() }}
        run: |
          python3 scripts/ci/emit_ios_diagnostics_summary.py \
            --label "iOS unsigned device build" \
            --result-json build/ResultBundle_archive.json \
            --result-json build/ResultBundle_resolve.json \
            --artifact-path build/diagnostics

      - name: Fallback note if device platform is missing
        if: ${{ steps.sdk.outputs.present != 'true' }}
        run: |
          echo "::warning title=Device platform unavailable::This runner image lacks the iOS Device platform. See uploaded xcresult for details."

      - name: Fail if compiler errors exist (archive)
        if: ${{ steps.sdk.outputs.present == 'true' }}
        run: |
          set -euo pipefail
          RB="${DERIVED_DATA}/ResultBundle_archive.xcresult"
          mkdir -p build
          if [ -d "$RB" ]; then
            TMP_ERR="$(mktemp)"
            if ! xcrun xcresulttool get --legacy --path "$RB" --format json \
              > build/ResultBundle_archive.json 2>"$TMP_ERR"; then
              if ! xcrun xcresulttool get --path "$RB" --format json \
                > build/ResultBundle_archive.json 2>>"$TMP_ERR"; then
                echo "::warning title=Archive xcresult export failed::See step logs for xcresulttool output"
                cat "$TMP_ERR" >&2 || true
                rm -f build/ResultBundle_archive.json || true
              fi
            fi
            rm -f "$TMP_ERR"
            if [ -f build/ResultBundle_archive.json ] && \
              grep -q '"Swift Compiler Error"' build/ResultBundle_archive.json; then
              echo "::error title=Swift compile errors detected::See ResultBundle_archive.json artifact."
              exit 65
            fi
          else
            echo "::error title=No archive result bundle::Archive likely failed before xcresult creation."
            exit 65
          fi

      - name: Package unsigned IPA from archive (robust)
        if: ${{ steps.sdk.outputs.present == 'true' }}
        run: |
          ./scripts/package_ipa.sh "$DERIVED_DATA/Archive.xcarchive" "$OUTPUT_DIR" "$SCHEME"

      - name: Upload archive artifacts
        if: ${{ always() }}
        uses: actions/upload-artifact@de65e23aa2b7e23d713bb51fbfcb6d502f8667d8
        with:
          name: ios-archive-and-ipa
          path: |
            ${{ env.OUTPUT_DIR }}/*.ipa
            ${{ env.OUTPUT_DIR }}/*.zip
            ${{ env.OUTPUT_DIR }}/build-log.txt
            ${{ env.DERIVED_DATA }}/Archive.xcarchive
            ${{ env.DERIVED_DATA }}/ResultBundle_archive.xcresult
            build/ResultBundle_archive.json
            build/ResultBundle_resolve.json
            build/diagnostics
          if-no-files-found: warn
          compression-level: 6
