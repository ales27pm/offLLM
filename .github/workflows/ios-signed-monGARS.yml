name: iOS Signed â€“ monGARS

on:
  workflow_dispatch:
    inputs:
      export_method:
        description: "Export method: ad-hoc | development | app-store"
        required: false
        default: "ad-hoc"
  push:
    branches: [main, master]

env:
  SCHEME: monGARS
  WORKING_DIR: ios
  DERIVED_DATA: build/DerivedData
  ARCHIVE_PATH: build/monGARS.xcarchive
  EXPORT_DIR: build/export
  RESULT_BUNDLE: build/DerivedData/ResultBundle_build.xcresult
  XCODE_PROJECT_NAME: monGARS.xcodeproj

jobs:
  build-signed-ipa:
    runs-on: macos-15
    timeout-minutes: 60

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Select latest Xcode 16 on macOS 15
        run: |
          XCODE_PATH="$(/usr/bin/mdfind 'kMDItemCFBundleIdentifier = "com.apple.dt.Xcode" && kMDItemVersion >= "16.0"' | head -n 1)"
          sudo xcode-select -s "$XCODE_PATH"
          xcodebuild -version

      - name: Verify required secrets
        run: |
          set -euo pipefail
          for name in P12_BASE64 MOBILEPROVISION_BASE64 TEAM_ID; do
            if [ -z "${!name:-}" ]; then echo "::error ::Missing secret: $name"; exit 1; fi
          done
        env:
          P12_BASE64: ${{ secrets.P12_BASE64 }}
          MOBILEPROVISION_BASE64: ${{ secrets.MOBILEPROVISION_BASE64 }}
          TEAM_ID: ${{ secrets.TEAM_ID }}

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Setup Bun
        if: hashFiles('bun.lockb') != ''
        uses: oven-sh/setup-bun@f4d14e03ff726c06358e5557344e1da148b56cf7

      - name: Install JS deps
        run: |
          if [ -f yarn.lock ]; then yarn install --frozen-lockfile; fi
          if [ -f pnpm-lock.yaml ]; then corepack enable && pnpm i --frozen-lockfile; fi
          if [ -f bun.lockb ]; then bun install --no-save; fi

      - name: Install Ruby & CocoaPods
        run: |
          ruby -v
          gem install bundler -N || true
          sudo gem install cocoapods -N
          pod --version

      - name: Generate Xcode project (XcodeGen)
        working-directory: ${{ env.WORKING_DIR }}
        run: |
          if ! command -v xcodegen >/dev/null 2>&1; then brew install xcodegen; fi
          xcodegen generate
          test -d "${{ env.XCODE_PROJECT_NAME }}" || { echo "::error ::XcodeGen failed"; exit 1; }

      - name: Pod install
        working-directory: ${{ env.WORKING_DIR }}
        run: |
          pod repo update
          pod install --verbose

      - name: (Optional) Pre-archive prep
        run: |
          bash scripts/ci/prep-ios-unsigned-archive.sh || true

      - name: Write signing files
        id: files
        working-directory: ${{ env.WORKING_DIR }}
        env:
          P12_BASE64: ${{ secrets.P12_BASE64 }}
          MOBILEPROVISION_BASE64: ${{ secrets.MOBILEPROVISION_BASE64 }}
        run: |
          set -euo pipefail
          mkdir -p signing
          echo "$P12_BASE64" | base64 -d > signing/cert.p12
          echo "$MOBILEPROVISION_BASE64" | base64 -d > signing/profile.mobileprovision
          ls -la signing

      - name: Import signing into temp keychain
        id: signing
        working-directory: ${{ env.WORKING_DIR }}
        env:
          P12_PASSWORD: ${{ secrets.P12_PASSWORD }}
        run: |
          set -euo pipefail
          KEYCHAIN_NAME="build-signing.keychain-db"
          KEYCHAIN_PWD="$(uuidgen)"
          bash ../scripts/ci/import_signing.sh \
            signing/cert.p12 "${P12_PASSWORD:-}" signing/profile.mobileprovision \
            "$KEYCHAIN_NAME" "$KEYCHAIN_PWD"

      - name: Determine bundle id & export method
        id: meta
        env:
          BUNDLE_ID: ${{ secrets.BUNDLE_ID }}
          INPUT_METHOD: ${{ github.event.inputs.export_method }}
          SECRET_METHOD: ${{ secrets.EXPORT_METHOD }}
        run: |
          set -euo pipefail
          BUNDLE_ID="${BUNDLE_ID:-com.offllm.monGARS}"
          METHOD="${INPUT_METHOD:-${SECRET_METHOD:-ad-hoc}}"
          echo "bundle_id=$BUNDLE_ID" >> "$GITHUB_OUTPUT"
          echo "method=$METHOD" >> "$GITHUB_OUTPUT"
          echo "Using bundle id: $BUNDLE_ID, method: $METHOD"

      - name: Patch ExportOptions.plist with provisioning mapping
        working-directory: ${{ env.WORKING_DIR }}
        env:
          BUNDLE_ID: ${{ steps.meta.outputs.bundle_id }}
          METHOD: ${{ steps.meta.outputs.method }}
        run: |
          set -euo pipefail
          # Prefer repo file if present, otherwise create a minimal one
          if [ -f export-options.plist ]; then
            cp export-options.plist ExportOptions.plist
          else
            cat > ExportOptions.plist <<'PLIST'
            <?xml version="1.0" encoding="UTF-8"?>
            <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
            <plist version="1.0"><dict>
            <key>method</key><string>ad-hoc</string>
            <key>signingStyle</key><string>manual</string>
            <key>stripSwiftSymbols</key><true/>
            <key>compileBitcode</key><false/>
            </dict></plist>
            PLIST
          fi
          # Set method
          /usr/libexec/PlistBuddy -c "Set :method ${METHOD}" ExportOptions.plist || true
          # Map provisioningProfiles: { <bundle_id>: <profile_name> }
          PROFILE_NAME=$(security cms -D -i signing/profile.mobileprovision | /usr/libexec/PlistBuddy -c 'Print :Name' /dev/stdin 2>/dev/null || true)
          [ -z "$PROFILE_NAME" ] && PROFILE_NAME="$BUNDLE_ID"
          /usr/libexec/PlistBuddy -c "Add :provisioningProfiles dict" ExportOptions.plist 2>/dev/null || true
          /usr/libexec/PlistBuddy -c "Add :provisioningProfiles:${BUNDLE_ID} string ${PROFILE_NAME}" ExportOptions.plist 2>/dev/null || \
          /usr/libexec/PlistBuddy -c "Set :provisioningProfiles:${BUNDLE_ID} ${PROFILE_NAME}" ExportOptions.plist
          /usr/libexec/PlistBuddy -c "Print" ExportOptions.plist

      - name: Build & Archive (signed)
        working-directory: ${{ env.WORKING_DIR }}
        env:
          TEAM_ID: ${{ secrets.TEAM_ID }}
          KEYCHAIN_PATH: ${{ env.KEYCHAIN_PATH }}
          BUNDLE_ID: ${{ steps.meta.outputs.bundle_id }}
        run: |
          set -euo pipefail
          test -n "$TEAM_ID"
          # Prefer the workspace made by CocoaPods
          PROJECT_FLAG="-workspace monGARS.xcworkspace"
          mkdir -p "${DERIVED_DATA}"
          xcodebuild \
            $PROJECT_FLAG \
            -scheme "${SCHEME}" \
            -configuration Release \
            -destination "generic/platform=iOS" \
            -archivePath "${ARCHIVE_PATH}" \
            -derivedDataPath "${DERIVED_DATA}" \
            -resultBundlePath "${RESULT_BUNDLE}" \
            CODE_SIGN_STYLE=Manual \
            DEVELOPMENT_TEAM="${TEAM_ID}" \
            PRODUCT_BUNDLE_IDENTIFIER="${BUNDLE_ID}" \
            OTHER_CODE_SIGN_FLAGS="--keychain ${KEYCHAIN_PATH}" \
            clean archive | xcpretty && exit ${PIPESTATUS[0]}

      - name: Export signed IPA
        working-directory: ${{ env.WORKING_DIR }}
        run: |
          set -euo pipefail
          rm -rf "${EXPORT_DIR}"
          bash ../scripts/ci/export_ipa.sh "${ARCHIVE_PATH}" "ExportOptions.plist" "${EXPORT_DIR}"

      - name: Upload IPA & logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: monGARS-signed-ipa
          path: |
            ios/build/export/*.ipa
            ios/ExportOptions.plist
            ios/build/DerivedData/ResultBundle_build.xcresult
          if-no-files-found: warn

      - name: Cleanup keychain
        if: always()
        run: |
          set -euo pipefail
          # variables exported by import_signing.sh in GITHUB_ENV
          if [[ -n "${ORIGINAL_DEFAULT_KEYCHAIN:-}" ]]; then
            security default-keychain -s "${ORIGINAL_DEFAULT_KEYCHAIN}" || true
          fi
          if [[ -n "${ORIGINAL_KEYCHAIN_LIST:-}" ]]; then
            RESTORE_KEYCHAINS=()
            while IFS= read -r kc; do [[ -z "$kc" ]] || RESTORE_KEYCHAINS+=("$kc"); done <<<"${ORIGINAL_KEYCHAIN_LIST}"
            [[ ${#RESTORE_KEYCHAINS[@]} -gt 0 ]] && security list-keychains -d user -s "${RESTORE_KEYCHAINS[@]}" || true
          fi
          [[ -n "${KEYCHAIN_PATH:-}" && -e "${KEYCHAIN_PATH}" ]] && security delete-keychain "${KEYCHAIN_PATH}" || true
