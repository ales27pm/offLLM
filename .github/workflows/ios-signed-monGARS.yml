name: Build iOS App (monGARS)

on:
  workflow_dispatch:
    inputs:
      require_signing:
        description: Skip secret validation and signed build when set to "false".
        required: false
        default: "true"
  push:
    branches: [main]

env:
  SIGNING_SECRET_NAMES: |
    P12_BASE64
    MOBILEPROVISION_BASE64
    P12_PASSWORD
    KEYCHAIN_PASSWORD
    APPLE_TEAM_ID

jobs:
  signing_precheck:
    runs-on: ubuntu-latest
    permissions:
      contents: read
    outputs:
      ready: ${{ toJSON(steps.precheck_result.outputs.ready == 'true') }}
      message: ${{ steps.precheck_result.outputs.message || 'Signed build readiness unavailable.' }}
    steps:
      - name: Determine signing requirement
        id: require_signing
        shell: bash
        env:
          EVENT_NAME: ${{ github.event_name }}
          INPUT_REQUIRE_SIGNING: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.require_signing || '' }}
        run: |
          set -euo pipefail

          raw_input="$INPUT_REQUIRE_SIGNING"
          if [[ "$EVENT_NAME" != "workflow_dispatch" || -z "$raw_input" ]]; then
            raw_input="true"
          fi

          normalized="$(printf '%s' "$raw_input" | tr '[:upper:]' '[:lower:]')"
          case "$normalized" in
            true|1|yes|on)
              normalized="true"
              ;;
            false|0|no|off)
              normalized="false"
              ;;
            *)
              echo "::warning ::Unknown require_signing value '$raw_input'; defaulting to true."
              normalized="true"
              ;;
          esac

          echo "require_signing=$normalized" >>"$GITHUB_OUTPUT"

      - name: Checkout repository
        if: ${{ steps.require_signing.outputs.require_signing == 'true' }}
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Evaluate signing secrets
        if: ${{ steps.require_signing.outputs.require_signing == 'true' }}
        id: evaluate
        uses: ./.github/actions/signing-secrets-check
        with:
          required-secrets: ${{ env.SIGNING_SECRET_NAMES }}
        env:
          P12_BASE64: ${{ secrets.P12_BASE64 }}
          MOBILEPROVISION_BASE64: ${{ secrets.MOBILEPROVISION_BASE64 }}
          P12_PASSWORD: ${{ secrets.P12_PASSWORD }}
          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}

      - name: Finalize signing precheck result
        id: precheck_result
        shell: bash
        env:
          REQUIRE_SIGNING: ${{ steps.require_signing.outputs.require_signing }}
          READY: ${{ steps.evaluate.outputs.ready }}
          MISSING: ${{ steps.evaluate.outputs.missing }}
        run: |
          set -euo pipefail

          if [[ "$REQUIRE_SIGNING" != "true" ]]; then
            echo "ready=false" >>"$GITHUB_OUTPUT"
            echo "message=Signed build skipped via workflow input." >>"$GITHUB_OUTPUT"
            exit 0
          fi

          ready_value="$READY"
          if [[ -z "$ready_value" ]]; then
            ready_value="false"
          fi

          missing_value="${MISSING:-}"

          if [[ "$ready_value" == "true" ]]; then
            echo "message=All signing secrets detected; proceeding with signed build." >>"$GITHUB_OUTPUT"
          else
            summary="Missing signing secrets; skipping signed build."
            if [[ -n "${missing_value// }" ]]; then
              summary+=" Missing: ${missing_value}."
            fi
            echo "message=${summary}" >>"$GITHUB_OUTPUT"
          fi

          echo "ready=$ready_value" >>"$GITHUB_OUTPUT"

      - name: Summarize signing gate
        if: ${{ always() }}
        env:
          READY: ${{ steps.precheck_result.outputs.ready }}
          SUMMARY_MESSAGE: ${{ steps.precheck_result.outputs.message }}
          MISSING: ${{ steps.evaluate.outputs.missing }}
        run: |
          {
            echo "## Signing precheck"
            echo ""
            echo "- Ready: \`$READY\`"
            echo "- Details: $SUMMARY_MESSAGE"
            missing_list="${MISSING:-}"
            if [[ -n "${missing_list// }" ]]; then
              missing_list="$(printf '%s' "$missing_list" | tr ',' ', ')"
              echo "- Missing secrets: $missing_list"
            fi
          } >>"$GITHUB_STEP_SUMMARY"

  build:
    needs: signing_precheck
    if: ${{ (github.event_name != 'pull_request' || github.event.pull_request.head.repo.full_name == github.repository) && needs.signing_precheck.result == 'success' && fromJSON(needs.signing_precheck.outputs.ready) }}
    runs-on: macos-15
    timeout-minutes: 60

    env:
      APP_NAME: monGARS
      SCHEME: monGARS
      CONFIGURATION: Release
      TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
      BUNDLE_ID: com.27pm.monGARS
      PROFILE_NAME: monGARS_Profile.mobileprovision
      KEYCHAIN_NAME: build-signing.keychain-db
      KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
      P12_PASSWORD: ${{ secrets.P12_PASSWORD }}
      SIGNING_CERTIFICATE: Apple Distribution

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"

      - name: Set up Ruby
        uses: ruby/setup-ruby@0481980f17b760ef6bca5e8c55809102a0af1e5a # v1
        with:
          ruby-version: "3.2"
          bundler-cache: true

      - name: Capture original keychain state
        run: |
          set -euo pipefail
          DEFAULT_LINE="$(security default-keychain -d user 2>/dev/null || true)"
          if [[ -n "${DEFAULT_LINE// }" ]]; then
            DEFAULT_LINE="$(printf '%s' "$DEFAULT_LINE" | sed -e 's/^[[:space:]]*"//' -e 's/"$//')"
            if [[ -n "$DEFAULT_LINE" ]]; then
              {
                echo "ORIGINAL_DEFAULT_KEYCHAIN<<EOF"
                echo "$DEFAULT_LINE"
                echo "EOF"
              } >>"$GITHUB_ENV"
            fi
          fi

          LIST_OUTPUT="$(security list-keychains -d user 2>/dev/null || true)"
          if [[ -n "${LIST_OUTPUT// }" ]]; then
            CLEANED="$(printf '%s\n' "$LIST_OUTPUT" | sed -e 's/^[[:space:]]*"//' -e 's/"$//')"
            CLEANED="$(printf '%s\n' "$CLEANED" | sed '/^$/d')"
            if [[ -n "$CLEANED" ]]; then
              {
                echo "ORIGINAL_KEYCHAIN_LIST<<EOF"
                echo "$CLEANED"
                echo "EOF"
              } >>"$GITHUB_ENV"
            fi
          fi

      - name: Cache CocoaPods
        uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830 # v4
        with:
          path: |
            ios/Pods
            ~/Library/Caches/CocoaPods
          key: ${{ runner.os }}-pods-${{ hashFiles('ios/Podfile.lock') }}
          restore-keys: ${{ runner.os }}-pods-

      - name: Install Dependencies (Node + Pods)
        run: |
          set -euxo pipefail
          if ! brew list xcodegen >/dev/null 2>&1; then
            HOMEBREW_NO_AUTO_UPDATE=1 brew install xcodegen
          fi
          npm ci
          xcodegen generate --spec ios/project.yml --project ios
          bundle exec pod install --project-directory=ios --repo-update

      - name: Decode signing assets
        env:
          P12_BASE64: ${{ secrets.P12_BASE64 }}
          MOBILEPROVISION_BASE64: ${{ secrets.MOBILEPROVISION_BASE64 }}
        run: |
          set -euo pipefail
          mkdir -p signing
          python3 - <<'PY'
          import base64
          import binascii
          import os
          import sys
          from pathlib import Path

          files = {
              "P12_BASE64": Path("signing/cert.p12"),
              "MOBILEPROVISION_BASE64": Path(
                  f"signing/{os.environ['PROFILE_NAME']}"
              ),
          }

          for env_var, output_path in files.items():
              value = os.environ.get(env_var)
              if not value:
                  sys.stderr.write(
                      f"::error ::Missing signing secret {env_var}.\n"
                  )
                  sys.exit(1)
              try:
                  decoded = base64.b64decode(value, validate=True)
              except binascii.Error as exc:
                  sys.stderr.write(
                      f"::error ::Secret {env_var} is not valid base64: {exc}\n"
                  )
                  sys.exit(1)
              if not decoded:
                  sys.stderr.write(
                      f"::error ::Secret {env_var} decoded to 0 bytes.\n"
                  )
                  sys.exit(1)
              output_path.parent.mkdir(parents=True, exist_ok=True)
              output_path.write_bytes(decoded)
              try:
                  output_path.chmod(0o600)
              except Exception:
                  pass
          PY

      - name: Import certificate & provisioning profile
        env:
          KEYCHAIN_PASSWORD: ${{ env.KEYCHAIN_PASSWORD }}
          PROFILE_NAME: ${{ env.PROFILE_NAME }}
        run: |
          set -euo pipefail
          bash scripts/ci/import_signing.sh \
            signing/cert.p12 \
            "$P12_PASSWORD" \
            "signing/${PROFILE_NAME}" \
            "$KEYCHAIN_NAME" \
            "$KEYCHAIN_PASSWORD"

      - name: Sanitize signing workspace
        run: |
          rm -rf signing || true

      - name: Build and Archive
        run: |
          set -euo pipefail
          : "${TEAM_ID:?Missing TEAM_ID secret}"
          : "${BUNDLE_ID:?Missing BUNDLE_ID}"
          : "${KEYCHAIN_PATH:?KEYCHAIN_PATH not set by signing import step}"
          : "${PROFILE_NAME:?Provisioning profile name unavailable}"
          xcodebuild \
            -workspace ios/monGARS.xcworkspace \
            -scheme "$SCHEME" \
            -configuration "$CONFIGURATION" \
            -sdk iphoneos \
            -archivePath build/$SCHEME.xcarchive \
            -derivedDataPath build/DerivedData \
            -destination "generic/platform=iOS" \
            CODE_SIGN_STYLE=Manual \
            DEVELOPMENT_TEAM="$TEAM_ID" \
            PRODUCT_BUNDLE_IDENTIFIER="$BUNDLE_ID" \
            PROVISIONING_PROFILE_SPECIFIER="$PROFILE_NAME" \
            CODE_SIGN_IDENTITY="$SIGNING_CERTIFICATE" \
            OTHER_CODE_SIGN_FLAGS="--keychain $KEYCHAIN_PATH" \
            archive

      - name: Create exportOptions.plist
        run: |
          set -euo pipefail
          cat > exportOptions.plist <<EOF
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
            <key>method</key><string>ad-hoc</string>
            <key>teamID</key><string>${TEAM_ID}</string>
            <key>provisioningProfiles</key>
            <dict>
              <key>${BUNDLE_ID}</key><string>${PROFILE_NAME}</string>
            </dict>
            <key>signingCertificate</key><string>${SIGNING_CERTIFICATE}</string>
            <key>signingStyle</key><string>manual</string>
            <key>stripSwiftSymbols</key><true/>
            <key>compileBitcode</key><false/>
            <key>destination</key><string>export</string>
          </dict>
          </plist>
          EOF

      - name: Export IPA
        run: |
          set -euo pipefail
          xcodebuild -exportArchive \
            -archivePath build/$SCHEME.xcarchive \
            -exportOptionsPlist exportOptions.plist \
            -exportPath build/export

      - name: Upload IPA artifact
        uses: actions/upload-artifact@v4
        with:
          name: monGARS.ipa
          path: build/export/*.ipa

      - name: Cleanup signing keychain
        if: always()
        run: |
          set -euo pipefail
          rm -rf signing || true
          if [[ -n "${ORIGINAL_DEFAULT_KEYCHAIN:-}" ]]; then
            security default-keychain -s "${ORIGINAL_DEFAULT_KEYCHAIN}" || true
          fi
          if [[ -n "${ORIGINAL_KEYCHAIN_LIST:-}" ]]; then
            RESTORE_KEYCHAINS=()
            while IFS= read -r kc; do
              [[ -z "$kc" ]] && continue
              RESTORE_KEYCHAINS+=("$kc")
            done <<<"${ORIGINAL_KEYCHAIN_LIST}"
            if [[ ${#RESTORE_KEYCHAINS[@]} -gt 0 ]]; then
              security list-keychains -d user -s "${RESTORE_KEYCHAINS[@]}" || true
            fi
          fi
          if [[ -n "${KEYCHAIN_PATH:-}" && -e "${KEYCHAIN_PATH}" ]]; then
            security delete-keychain "${KEYCHAIN_PATH}" || true
          fi
