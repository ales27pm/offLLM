name: iOS AdHoc Signed IPA

on:
  workflow_dispatch:
  push:
    branches: [main, master]
  pull_request:

jobs:
  build-adhoc:
    if: ${{ github.event_name != 'pull_request' || github.event.pull_request.head.repo.full_name == github.repository }}
    runs-on: macos-15
    environment: offLLM

    env:
      SCHEME: monGARS
      CONFIGURATION: Release
      ARCHIVE_PATH: build/monGARS.xcarchive
      DERIVED_DATA: build/DerivedData
      RESULT_BUNDLE: build/DerivedData/ResultBundle_build.xcresult
      XCRESULT_JSON: ""

      BUNDLE_ID_PREFIX: a.export
      BUNDLE_ID_SUFFIX: monGARS
      TEAM_ID: ${{ secrets.TEAM_ID }}

      KEYCHAIN_NAME: build-signing.keychain-db

    steps:
      - name: Checkout
        uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955

      - name: Decode signing files
        env:
          P12_BASE64: ${{ secrets.P12_BASE64 }}
          MOBILEPROVISION_BASE64: ${{ secrets.MOBILEPROVISION_BASE64 }}
        run: |
          python - <<'PY'
          import base64
          import binascii
          import os
          import sys
          from pathlib import Path

          secrets_to_paths = {
              "P12_BASE64": Path("signing/cert.p12"),
              "MOBILEPROVISION_BASE64": Path("signing/profile.mobileprovision"),
          }

          for env_var, output_path in secrets_to_paths.items():
              value = os.environ.get(env_var)
              if not value:
                  sys.stderr.write(
                      f"::error ::Missing signing secret {env_var}. "
                      "Add it to the repository or environment secrets before rerunning.\n"
                  )
                  sys.exit(1)

              try:
                  decoded = base64.b64decode(value, validate=True)
              except binascii.Error as exc:
                  sys.stderr.write(
                      f"::error ::Secret {env_var} is not valid base64: {exc}\n"
                  )
                  sys.exit(1)

              if not decoded:
                  sys.stderr.write(
                      f"::error ::Secret {env_var} decoded to 0 bytes. "
                      "Verify the uploaded file and try again.\n"
                  )
                  sys.exit(1)

              output_path.parent.mkdir(parents=True, exist_ok=True)
              output_path.write_bytes(decoded)
              try:
                  output_path.chmod(0o600)
              except Exception:
                  pass
          PY

      - name: Import certificate & provisioning profile
        env:
          P12_PASSWORD: ${{ secrets.P12_PASSWORD }}
          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
        run: |
          bash scripts/ci/import_signing.sh \
            signing/cert.p12 \
            "$P12_PASSWORD" \
            signing/profile.mobileprovision \
            "$KEYCHAIN_NAME" \
            "$KEYCHAIN_PASSWORD"

      - name: Sanitize signing files
        run: |
          rm -rf signing || true

      - name: Set up Ruby 3.2
        uses: ruby/setup-ruby@44511735964dcb71245e7e55f72539531f7bc0eb
        with:
          ruby-version: "3.2.9"
          bundler-cache: true

      - name: Install XcodeGen
        run: brew install xcodegen

      - name: Install xcresulttool
        run: |
          set -euo pipefail
          if xcrun --find xcresulttool >/dev/null 2>&1; then
            echo "xcresulttool available via xcrun"
            exit 0
          fi

          if ! command -v brew >/dev/null 2>&1; then
            echo "::warning ::Homebrew unavailable; cannot install xcresulttool"
            exit 0
          fi

          if ! brew tap chargepoint/xcresulttool; then
            echo "::warning ::Failed to tap chargepoint/xcresulttool; xcresulttool may be unavailable"
          fi

          if ! brew list xcresulttool >/dev/null 2>&1; then
            if ! brew install xcresulttool; then
              echo "::warning ::brew install xcresulttool failed; xcresulttool may be unavailable"
            fi
          fi

      - name: Generate Xcode project
        run: |
          set -euo pipefail
          npm ci
          xcodegen generate --spec ios/project.yml --project ios
          if [ -f ios/Gemfile ]; then
            bundle install --gemfile=ios/Gemfile
            bundle exec --gemfile=ios/Gemfile pod install --project-directory=ios --repo-update
          else
            pod install --project-directory=ios --repo-update
          fi
          ls -la ios
          if [ -f ios/monGARS.xcodeproj/project.pbxproj ]; then
            xcodebuild -list -project ios/monGARS.xcodeproj
          else
            echo "::error ::ios/monGARS.xcodeproj was not generated"
            exit 1
          fi
          if [ -f ios/monGARS.xcworkspace/contents.xcworkspacedata ]; then
            xcodebuild -list -workspace ios/monGARS.xcworkspace
          else
            echo "::error ::ios/monGARS.xcworkspace was not generated by CocoaPods"
            exit 1
          fi

      - name: Xcode Archive (manual signing)
        run: |
          set -euxo pipefail
          rm -rf "$ARCHIVE_PATH" "$DERIVED_DATA" "$RESULT_BUNDLE" || true
          : "${BUNDLE_ID_SUFFIX:?BUNDLE_ID_SUFFIX is required and must not be empty}"
          BUNDLE_ID="${BUNDLE_ID_PREFIX}.${BUNDLE_ID_SUFFIX}"
          KEYCHAIN_PATH="${KEYCHAIN_PATH:?KEYCHAIN_PATH not set by signing import step}"
          echo "RESOLVED_BUNDLE_ID=$BUNDLE_ID" >> "$GITHUB_ENV"
          echo "== Codesign identities in keychain =="
          security find-identity -v -p codesigning "$KEYCHAIN_PATH" || true
          xcodebuild \
            -workspace ios/monGARS.xcworkspace \
            -scheme "$SCHEME" \
            -configuration "$CONFIGURATION" \
            -archivePath "$ARCHIVE_PATH" \
            -destination "generic/platform=iOS" \
            -derivedDataPath "$DERIVED_DATA" \
            -resultBundlePath "$RESULT_BUNDLE" \
            archive \
            CODE_SIGN_STYLE=Manual \
            DEVELOPMENT_TEAM="${TEAM_ID}" \
            PRODUCT_BUNDLE_IDENTIFIER="$BUNDLE_ID" \
            CODE_SIGN_IDENTITY="Apple Distribution" \
            OTHER_CODE_SIGN_FLAGS="--keychain $KEYCHAIN_PATH"

      - name: Create exportOptions.plist
        run: |
          BUNDLE_ID="${RESOLVED_BUNDLE_ID:-${BUNDLE_ID_PREFIX}.${BUNDLE_ID_SUFFIX}}"
          cat > exportOptions.plist <<PLIST
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
            <key>method</key><string>release-testing</string>
            <key>signingStyle</key><string>manual</string>
            <key>teamID</key><string>${TEAM_ID}</string>
            <key>stripSwiftSymbols</key><true/>
            <key>destination</key><string>export</string>
            <key>provisioningProfiles</key>
            <dict>
              <key>${BUNDLE_ID}</key><string>${PROFILE_NAME}</string>
            </dict>
          </dict>
          </plist>
          PLIST

      - name: Export IPA
        run: |
          bash scripts/ci/export_ipa.sh "$ARCHIVE_PATH" exportOptions.plist export

      - name: Upload IPA
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02
        with:
          name: monGARS-AdHoc-IPA
          path: export/*.ipa

      - name: Convert xcresult to JSON
        if: always()
        run: |
          set -euo pipefail
          bundle_path="${RESULT_BUNDLE}"
          if [ ! -d "${bundle_path}" ]; then
            echo "::warning ::xcresult bundle ${bundle_path} missing; skipping JSON conversion"
            exit 0
          fi

          json_path="${bundle_path}.json"
          tmp_err="$(mktemp)"

          supports_legacy="unknown"
          if help_output="$(xcrun xcresulttool get --help 2>&1)"; then
            if printf '%s' "$help_output" | grep -qi -- '--legacy'; then
              supports_legacy="yes"
            else
              supports_legacy="no"
            fi
          fi

          try_legacy_first="yes"
          if [ "$supports_legacy" = "no" ]; then
            try_legacy_first="no"
          fi

          convert_variant() {
            local variant="$1"
            if [ "$variant" = "legacy" ]; then
              xcrun xcresulttool get --format json --legacy --path "${bundle_path}" >"${json_path}" 2>"$tmp_err"
            else
              xcrun xcresulttool get --format json --path "${bundle_path}" >"${json_path}" 2>"$tmp_err"
            fi
          }

          success=0
          if [ "$try_legacy_first" = "yes" ]; then
            if convert_variant legacy; then
              success=1
            elif convert_variant modern; then
              success=1
            fi
          else
            if convert_variant modern; then
              success=1
            elif convert_variant legacy; then
              success=1
            fi
          fi

          if [ "$success" -eq 1 ]; then
            echo "XCRESULT_JSON=${json_path}" >> "$GITHUB_ENV"
          else
            echo "::warning ::Failed to convert ${bundle_path} to JSON: $(cat "$tmp_err" 2>/dev/null || true)"
            rm -f "${json_path}" || true
          fi

          rm -f "$tmp_err" || true

      - name: Upload Xcode result bundle
        if: always()
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02
        with:
          name: monGARS-xcresult
          path: ${{ env.RESULT_BUNDLE }}
          if-no-files-found: warn

      - name: Upload xcresult JSON
        if: ${{ always() && env.XCRESULT_JSON != '' }}
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02
        with:
          name: monGARS-xcresult-json
          path: ${{ env.XCRESULT_JSON }}
          if-no-files-found: warn

      - name: Upload exportOptions.plist
        if: always()
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02
        with:
          name: exportOptions
          path: exportOptions.plist
          if-no-files-found: warn

      - name: Cleanup keychain
        if: always()
        run: |
          LOGIN_KC="$HOME/Library/Keychains/login.keychain-db"
          [ -f "$LOGIN_KC" ] || LOGIN_KC="$HOME/Library/Keychains/login.keychain"
          SYSTEM_KC="/Library/Keychains/System.keychain"
          KC_PATH="${KEYCHAIN_PATH:-$HOME/Library/Keychains/$KEYCHAIN_NAME}"

          if [ -n "${ORIGINAL_DEFAULT_KEYCHAIN:-}" ]; then
            security default-keychain -s "$ORIGINAL_DEFAULT_KEYCHAIN" || true
          else
            security default-keychain -s "$LOGIN_KC" || true
          fi

          if [ -n "${ORIGINAL_KEYCHAIN_LIST:-}" ]; then
            OLDIFS=$IFS
            IFS=$'\n'
            RESTORE_LIST=()
            while IFS= read -r line; do
              [ -z "$line" ] && continue
              RESTORE_LIST+=("$line")
            done <<< "$ORIGINAL_KEYCHAIN_LIST"
            IFS=$OLDIFS
            if [ "${#RESTORE_LIST[@]}" -gt 0 ]; then
              security list-keychains -d user -s "${RESTORE_LIST[@]}" || true
            fi
          else
            FALLBACK_LIST=("$LOGIN_KC")
            [ -f "$SYSTEM_KC" ] && FALLBACK_LIST+=("$SYSTEM_KC")
            security list-keychains -d user -s "${FALLBACK_LIST[@]}" || true
          fi

          security delete-keychain "$KC_PATH" || true
          rm -rf signing || true
          if [ -n "${PROFILE_UUID:-}" ]; then
            rm -f "$HOME/Library/MobileDevice/Provisioning Profiles/${PROFILE_UUID}.mobileprovision" || true
          fi
