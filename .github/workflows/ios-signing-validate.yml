name: iOS Signing & Secrets Validation

on:
  workflow_dispatch:
    inputs:
      team_id:
        description: "Apple Team ID (e.g. 52T7P32J34)"
        required: true
        default: "52T7P32J34"
      bundle_id:
        description: "App Bundle ID (e.g. com.27pm.monGARS)"
        required: true
        default: "com.27pm.monGARS"
      device_udid:
        description: "Optional device UDID to verify in provisioning profile"
        required: false
        default: "00008140-000E4D6C14C0801C"
      export_method:
        description: "development | release-testing (ad-hoc) | app-store (only for completeness)"
        required: false
        default: "development"

jobs:
  validate-signing:
    runs-on: macos-15
    env:
      WORKING_DIR: ios
      KEYCHAIN_NAME: build-${{ github.run_id }}.keychain-db
    steps:
      - name: Checkout (shallow)
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Verify required secrets exist
        env:
          P12_BASE64: ${{ secrets.P12_BASE64 }}
          P12_PASSWORD: ${{ secrets.P12_PASSWORD }}
          MOBILEPROVISION_BASE64: ${{ secrets.MOBILEPROVISION_BASE64 }}
          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
        run: |
          set -euo pipefail
          missing=0
          for secret_name in P12_BASE64 P12_PASSWORD MOBILEPROVISION_BASE64 KEYCHAIN_PASSWORD; do
            value="${!secret_name:-}"
            if [[ -z "$value" ]]; then
              echo "::error ::Missing secret: $secret_name"
              missing=1
            fi
          done
          if [[ $missing -ne 0 ]]; then
            exit $missing
          fi
        shell: bash

      - name: Prepare signing files
        working-directory: ${{ env.WORKING_DIR }}
        env:
          P12_BASE64: ${{ secrets.P12_BASE64 }}
          MOBILEPROVISION_BASE64: ${{ secrets.MOBILEPROVISION_BASE64 }}
        run: |
          set -euo pipefail
          mkdir -p signing
          printf "%s" "$P12_BASE64" | base64 -d > signing/cert.p12
          printf "%s" "$MOBILEPROVISION_BASE64" | base64 -d > signing/profile.mobileprovision
          ls -la signing

      - name: Create & unlock temporary keychain
        env:
          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
        run: |
          set -euo pipefail
          KEYCHAIN_PATH="$RUNNER_TEMP/${KEYCHAIN_NAME}"

          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          # Save originals so we can restore on cleanup
          echo "ORIGINAL_DEFAULT_KEYCHAIN=$(security default-keychain | sed 's/.*"\(.*\)".*/\1/')" >> $GITHUB_ENV
          echo "ORIGINAL_KEYCHAIN_LIST=$(security list-keychains -d user | sed 's/.*"\(.*\)".*/\1/')" >> $GITHUB_ENV

          echo "KEYCHAIN_PATH=$KEYCHAIN_PATH" >> $GITHUB_ENV

          # Put temp keychain first
          security list-keychains -d user -s "$KEYCHAIN_PATH" $ORIGINAL_KEYCHAIN_LIST
          security default-keychain -s "$KEYCHAIN_PATH"

      - name: Import certificate into keychain
        working-directory: ${{ env.WORKING_DIR }}
        env:
          P12_PASSWORD: ${{ secrets.P12_PASSWORD }}
        run: |
          set -euo pipefail
          security import signing/cert.p12 -k "$KEYCHAIN_PATH" -P "$P12_PASSWORD" -T /usr/bin/codesign -T /usr/bin/security
          echo "=== Codesigning identities in temp keychain ==="
          security find-identity -p codesigning -v "$KEYCHAIN_PATH" || true

      - name: Decode provisioning profile and validate essentials
        working-directory: ${{ env.WORKING_DIR }}
        env:
          INPUT_TEAM_ID: ${{ github.event.inputs.team_id }}
          INPUT_BUNDLE_ID: ${{ github.event.inputs.bundle_id }}
          INPUT_UDID: ${{ github.event.inputs.device_udid }}
        run: |
          set -euo pipefail
          TMP_PLIST=$(mktemp)
          security cms -D -i signing/profile.mobileprovision > "$TMP_PLIST"

          PROFILE_NAME=$(/usr/libexec/PlistBuddy -c 'Print :Name' "$TMP_PLIST")
          PROFILE_UUID=$(/usr/libexec/PlistBuddy -c 'Print :UUID' "$TMP_PLIST")
          APP_ID_FULL=$(/usr/libexec/PlistBuddy -c 'Print :Entitlements:application-identifier' "$TMP_PLIST")
          PROFILE_TEAM="${APP_ID_FULL%%.*}"

          echo "Profile Name     : $PROFILE_NAME"
          echo "Profile UUID     : $PROFILE_UUID"
          echo "Profile Team     : $PROFILE_TEAM"
          echo "Input Team ID    : $INPUT_TEAM_ID"
          echo "Input Bundle ID  : $INPUT_BUNDLE_ID"

          # Validate team id
          if [[ -n "$INPUT_TEAM_ID" && "$PROFILE_TEAM" != "$INPUT_TEAM_ID" ]]; then
            echo "::error ::Provisioning profile team ($PROFILE_TEAM) does not match input team ($INPUT_TEAM_ID)"
            exit 1
          fi

          # Validate bundle id match (wildcards allowed)
          case "$APP_ID_FULL" in
            "$INPUT_TEAM_ID.$INPUT_BUNDLE_ID") ;;
            "$INPUT_TEAM_ID.*")
              echo "::warning ::Profile is wildcard; ensure it truly matches entitlements at export time"
              ;;
            *)
              echo "::error ::Provisioning profile App ID ($APP_ID_FULL) does not cover $INPUT_TEAM_ID.$INPUT_BUNDLE_ID"
              exit 1
              ;;
          esac

          # If a UDID was provided, ensure it is present
          if /usr/libexec/PlistBuddy -c 'Print :ProvisionedDevices' "$TMP_PLIST" >/dev/null 2>&1; then
            if [[ -n "$INPUT_UDID" ]]; then
              if ! /usr/libexec/PlistBuddy -c 'Print :ProvisionedDevices' "$TMP_PLIST" | grep -qi "$INPUT_UDID"; then
                echo "::error ::Device UDID $INPUT_UDID is NOT included in the provisioning profile"
                exit 1
              else
                echo "UDID present in profile âœ…"
              fi
            else
              echo "ProvisionedDevices present; UDID check skipped (no UDID provided)."
            fi
          else
            echo "::error ::Provisioning profile has no ProvisionedDevices (not valid for dev/ad-hoc install)."
            exit 1
          fi
          rm -f "$TMP_PLIST"

      - name: Validate ExportOptions.plist generation (no build)
        working-directory: ${{ env.WORKING_DIR }}
        env:
          TEAM_ID: ${{ github.event.inputs.team_id }}
          BUNDLE_ID: ${{ github.event.inputs.bundle_id }}
          EXPORT_METHOD_IN: ${{ github.event.inputs.export_method }}
          KEYCHAIN_PATH: ${{ env.KEYCHAIN_PATH }}
          PROFILE_NAME: monGARS
        run: |
          set -euo pipefail

          # Detect identity labels (modern + legacy)
          IDS=$(security find-identity -p codesigning -v "$KEYCHAIN_PATH" 2>/dev/null | sed -n 's/.*"\(.*\)".*/\1/p' || true)
          echo "Identities found:"
          echo "$IDS"

          HAVE_DISTRIBUTION=0
          echo "$IDS" | grep -Eq '^(Apple|iOS|iPhone) Distribution(:|$)' && HAVE_DISTRIBUTION=1 || true

          HAVE_DEVELOPMENT=0
          echo "$IDS" | grep -Eq '^(Apple Development|iPhone Developer)(:|$)' && HAVE_DEVELOPMENT=1 || true

          DEV_LABEL=""; DIST_LABEL=""
          echo "$IDS" | grep -Eq '^Apple Development(:|$)' && DEV_LABEL="Apple Development" || true
          [[ -z "$DEV_LABEL" ]] && (echo "$IDS" | grep -Eq '^iPhone Developer(:|$)' && DEV_LABEL="iPhone Developer" || true)

          echo "$IDS" | grep -Eq '^Apple Distribution(:|$)' && DIST_LABEL="Apple Distribution" || true
          [[ -z "$DIST_LABEL" ]] && (echo "$IDS" | grep -Eq '^iPhone Distribution(:|$)' && DIST_LABEL="iPhone Distribution" || true)
          [[ -z "$DIST_LABEL" ]] && (echo "$IDS" | grep -Eq '^iOS Distribution(:|$)' && DIST_LABEL="iOS Distribution" || true)

          METHOD="${{ github.event.inputs.export_method }}"
          [[ -z "$METHOD" ]] && METHOD="development"
          [[ "$METHOD" == "ad-hoc" ]] && METHOD="release-testing"

          if [[ "$METHOD" == "release-testing" || "$METHOD" == "app-store" ]]; then
            if [[ $HAVE_DISTRIBUTION -eq 0 ]]; then
              echo "::warning ::No Distribution identity; falling back to development for validation"
              METHOD="development"
            fi
          fi
          if [[ "$METHOD" == "development" && $HAVE_DEVELOPMENT -eq 0 ]]; then
            echo "::error ::No Development identity found in temp keychain"
            exit 1
          fi

          # Build a valid ExportOptions.plist and ensure dotted bundle ID is handled
          rm -f ExportOptions.plist
          plutil -create xml1 ExportOptions.plist
          plutil -replace : -xml '<dict/>' ExportOptions.plist
          plutil -insert method -string "$METHOD" ExportOptions.plist
          plutil -insert signingStyle -string "manual" ExportOptions.plist
          [[ -n "$TEAM_ID" ]] && plutil -insert teamID -string "$TEAM_ID" ExportOptions.plist || true
          if [[ "$METHOD" == "development" ]]; then
            plutil -insert signingCertificate -string "${{ '{{' }} DEV_LABEL:-Apple Development {{ '}}' }}" ExportOptions.plist
          else
            plutil -insert signingCertificate -string "${{ '{{' }} DIST_LABEL:-Apple Distribution {{ '}}' }}" ExportOptions.plist
          fi
          plutil -insert stripSwiftSymbols -bool true ExportOptions.plist
          plutil -insert compileBitcode -bool false ExportOptions.plist

          # provisioningProfiles with dotted key via PlistBuddy
          /usr/libexec/PlistBuddy -c "Add :provisioningProfiles dict" ExportOptions.plist 2>/dev/null || true
          /usr/libexec/PlistBuddy -c "Add :provisioningProfiles:${{ github.event.inputs.bundle_id }} string ${PROFILE_NAME}" ExportOptions.plist 2>/dev/null ||           /usr/libexec/PlistBuddy -c "Set :provisioningProfiles:${{ github.event.inputs.bundle_id }} ${PROFILE_NAME}" ExportOptions.plist

          echo "==== ExportOptions.plist ===="
          /usr/libexec/PlistBuddy -c "Print" ExportOptions.plist || plutil -p ExportOptions.plist

      - name: Cleanup keychain
        if: always()
        run: |
          set -euo pipefail
          if [[ -n "${{ env.ORIGINAL_DEFAULT_KEYCHAIN }}" ]]; then
            security default-keychain -s "${{ env.ORIGINAL_DEFAULT_KEYCHAIN }}" || true
          fi
          if [[ -n "${{ env.ORIGINAL_KEYCHAIN_LIST }}" ]]; then
            security list-keychains -d user -s "${{ env.ORIGINAL_KEYCHAIN_LIST }}" || true
          fi
          [[ -e "$KEYCHAIN_PATH" ]] && security delete-keychain "$KEYCHAIN_PATH" || true
