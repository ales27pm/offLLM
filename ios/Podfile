require 'open3'
require 'fileutils'

platform :ios, '18.0'

def env_flag_enabled?(name, default:)
  raw = ENV[name]
  return default if raw.nil?

  normalized = raw.strip.downcase
  return true if %w[1 true yes on].include?(normalized)
  return false if %w[0 false no off].include?(normalized)

  default
end

def normalize_tokens(value)
  case value
  when nil
    [[], :array]
  when Array
    [value.compact.dup, :array]
  else
    [value.to_s.split(/\s+/), :string]
  end
end

def materialize_tokens(tokens, preference)
  filtered = tokens.compact
  return preference == :array ? [] : '' if filtered.empty?

  preference == :array ? filtered : filtered.join(' ')
end

def normalize_token(token)
  return nil if token.nil?

  normalized = token.to_s.strip

  loop do
    original = normalized
    normalized = normalized.sub(/\A\\?["']/, '')
    normalized = normalized.sub(/\\?["']\z/, '')
    break if normalized == original
  end

  if normalized.include?('=')
    prefix, suffix = normalized.split('=', 2)
    stripped_suffix = suffix.strip

    loop do
      original_suffix = stripped_suffix
      stripped_suffix = stripped_suffix.sub(/\A\\?["']/, '')
      stripped_suffix = stripped_suffix.sub(/\\?["']\z/, '')
      break if stripped_suffix == original_suffix
    end

    normalized = "#{prefix}=#{stripped_suffix}"
  end

  normalized
end

def token_equals?(token, candidate)
  normalized_token = normalize_token(token)
  normalized_candidate = normalize_token(candidate)

  return false if normalized_token.nil? || normalized_candidate.nil?

  normalized_token == normalized_candidate
end

def tokens_include_flag?(tokens, flag)
  tokens.any? { |token| token_equals?(token, flag) }
end

def append_flag(value, flag)
  return ['$(inherited)', flag] if value.nil?

  tokens, preference = normalize_tokens(value)
  return materialize_tokens(tokens, preference) if tokens_include_flag?(tokens, flag)

  tokens << flag
  materialize_tokens(tokens, preference)
end

def append_flags(value, flags)
  flags.reduce(value) { |memo, flag| append_flag(memo, flag) }
end

def remove_flag(value, flag)
  tokens, preference = normalize_tokens(value)
  original = tokens.dup
  tokens.reject! { |token| token_equals?(token, flag) }
  [materialize_tokens(tokens, preference), tokens != original]
end

def swift_flag_pair?(value, flag)
  return false if flag.nil?

  tokens, _ = normalize_tokens(value)
  tokens.each_cons(2).any? do |first, second|
    token_equals?(first, '-Xcc') && token_equals?(second, flag)
  end
end

def sanitize_module_map_settings(config, header_search_fix:, module_map_flags:, module_map_path:, legacy_module_map_flag:, force_tokens: false, enforce_module_map: false, enforce_defines_module: false)
  updated = false
  module_flag = module_map_flags.first

  existing_c_flags = config.build_settings['OTHER_CFLAGS']
  c_tokens, _ = normalize_tokens(existing_c_flags)
  contains_legacy_c_flag = tokens_include_flag?(c_tokens, legacy_module_map_flag)
  contains_canonical_c_flag = module_flag ? tokens_include_flag?(c_tokens, module_flag) : false

  existing_cpp_flags = config.build_settings['OTHER_CPLUSPLUSFLAGS']
  cpp_tokens, _ = normalize_tokens(existing_cpp_flags)
  contains_legacy_cpp_flag = tokens_include_flag?(cpp_tokens, legacy_module_map_flag)
  contains_canonical_cpp_flag = module_flag ? tokens_include_flag?(cpp_tokens, module_flag) : false

  existing_swift_flags = config.build_settings['OTHER_SWIFT_FLAGS']
  contains_legacy_swift = swift_flag_pair?(existing_swift_flags, legacy_module_map_flag)
  contains_canonical_swift = swift_flag_pair?(existing_swift_flags, module_flag)

  requires_tokens = force_tokens || contains_legacy_c_flag || contains_canonical_c_flag ||
                    contains_legacy_cpp_flag || contains_canonical_cpp_flag ||
                    contains_legacy_swift || contains_canonical_swift

  if requires_tokens
    existing_header_paths = config.build_settings['HEADER_SEARCH_PATHS']
    desired_header_paths = append_flag(existing_header_paths, header_search_fix)
    if desired_header_paths != existing_header_paths
      config.build_settings['HEADER_SEARCH_PATHS'] = desired_header_paths
      updated = true
    end
  end

  if contains_legacy_c_flag
    pruned_c_flags, _ = remove_flag(existing_c_flags, legacy_module_map_flag)
    config.build_settings['OTHER_CFLAGS'] = pruned_c_flags
    existing_c_flags = pruned_c_flags
    updated = true
  end

  if requires_tokens
    updated_c_flags = append_flags(existing_c_flags, module_map_flags)
    if updated_c_flags != existing_c_flags
      config.build_settings['OTHER_CFLAGS'] = updated_c_flags
      updated = true
    end
  end

  if contains_legacy_cpp_flag
    pruned_cpp_flags, _ = remove_flag(existing_cpp_flags, legacy_module_map_flag)
    config.build_settings['OTHER_CPLUSPLUSFLAGS'] = pruned_cpp_flags
    existing_cpp_flags = pruned_cpp_flags
    updated = true
  end

  if requires_tokens
    updated_cpp_flags = append_flags(existing_cpp_flags, module_map_flags)
    if updated_cpp_flags != existing_cpp_flags
      config.build_settings['OTHER_CPLUSPLUSFLAGS'] = updated_cpp_flags
      updated = true
    end
  end

  if requires_tokens
    swift_tokens, swift_changed = ensure_swift_module_flags(
      existing_swift_flags,
      module_map_flags,
      :forbidden_flags => [legacy_module_map_flag]
    )
    if swift_changed
      config.build_settings['OTHER_SWIFT_FLAGS'] = swift_tokens
      updated = true
    end
  end

  if enforce_module_map && config.build_settings['MODULEMAP_FILE'] != module_map_path
    config.build_settings['MODULEMAP_FILE'] = module_map_path
    updated = true
  end

  if enforce_defines_module && config.build_settings['DEFINES_MODULE'] != 'YES'
    config.build_settings['DEFINES_MODULE'] = 'YES'
    updated = true
  end

  updated
end

def ensure_swift_module_flags(swift_flags, module_map_flags, forbidden_flags: [])
  tokens, preference = normalize_tokens(swift_flags)
  changed = false

  unless tokens.include?('$(inherited)')
    tokens.unshift('$(inherited)')
    changed = true
  end

  forbidden_flags.each do |flag|
    before = tokens.length
    tokens.reject! { |token| token_equals?(token, flag) }
    changed ||= tokens.length != before

    loop do
      entry = tokens.each_cons(2).with_index.find do |(first, second), _i|
        token_equals?(first, '-Xcc') && token_equals?(second, flag)
      end
      break unless entry

      _, removal_index = entry
      tokens.slice!(removal_index, 2)
      changed = true
    end
  end

  original_tokens = tokens.dup
  cleaned_tokens = []
  index = 0
  while index < tokens.length
    token = tokens[index]

    if token_equals?(token, '-Xcc')
      next_token = tokens[index + 1]

      if next_token.nil? || token_equals?(next_token, '-Xcc')
        changed = true
        index += 1
        next
      end

      cleaned_tokens << token
      cleaned_tokens << next_token
      index += 2
      next
    end

    cleaned_tokens << token
    index += 1
  end

  if cleaned_tokens != original_tokens
    tokens = cleaned_tokens
    changed = true
  end

  module_map_flags.each do |flag|
    has_pair = tokens.each_cons(2).any? do |first, second|
      token_equals?(first, '-Xcc') && token_equals?(second, flag)
    end
    next if has_pair

    tokens << '-Xcc'
    tokens << flag
    changed = true
  end

  [materialize_tokens(tokens, preference), changed]
end

install! 'cocoapods', :disable_input_output_paths => true

# --- Auto-detect the .xcodeproj near this Podfile ---
#
project_candidates = Dir.glob(File.join(__dir__, '*.xcodeproj')).sort
preferred = ENV['XCODE_PROJECT_NAME']
project_path =
  if preferred && File.exist?(File.join(__dir__, "#{preferred}.xcodeproj"))
    File.join(__dir__, "#{preferred}.xcodeproj")
  elsif project_candidates.any?
    project_candidates.first
  else
    nil
  end

raise "No .xcodeproj found near Podfile (#{__dir__})" unless project_path
project File.basename(project_path)

begin
  rn_path = File.join(__dir__, '..', 'node_modules', 'react-native')
  require File.join(rn_path, 'scripts', 'react_native_pods')
rescue => e
  abort "[Podfile] Could not load React Native pod helpers: #{e.message}\n" \
        "[Podfile] Hint: run 'npm ci' (or 'yarn install') at repo root before 'pod install'."
end

prepare_react_native_project!

# Ensure glog/src/config.h exists (prevents 'config.h not found' CI errors)
pre_install do |installer|
  Pod::UI.puts 'Ensuring glog/src/config.h existsâ€¦'
  glog_src = File.join(installer.sandbox.root.to_s, 'glog', 'src')
  config_h = File.join(glog_src, 'config.h')
  config_ios = File.join(glog_src, 'config_ios.h')
  config_cmake = File.join(glog_src, 'config.h.cmake')

  if File.directory?(glog_src) && !File.exist?(config_h)
    if File.exist?(config_ios)
      FileUtils.cp(config_ios, config_h)
    elsif File.exist?(config_cmake)
      FileUtils.cp(config_cmake, config_h)
    end
  end
end

target 'monGARS' do
  config = use_native_modules!

  new_arch_enabled = env_flag_enabled?('RCT_NEW_ARCH_ENABLED', default: true)
  fabric_enabled = env_flag_enabled?('RCT_FABRIC_ENABLED', default: new_arch_enabled)

  flags = get_default_flags()

  use_react_native!(
    :path => config[:reactNativePath],
    :hermes_enabled => flags[:hermes_enabled],
    :fabric_enabled => fabric_enabled,
    :new_arch_enabled => new_arch_enabled,
    :app_path => "#{__dir__}/..",
    :config_file_dir => File.expand_path('..', __dir__)
  )

  # Add third-party pods only if present (keeps CI resilient)
  def add_pod_if_present(name, path)
    pod name, :path => path if File.exist?(File.join(__dir__, path))
  end

  add_pod_if_present 'RNCAsyncStorage', '../node_modules/@react-native-async-storage/async-storage'
  add_pod_if_present 'react-native-clipboard', '../node_modules/@react-native-community/clipboard'
  add_pod_if_present 'react-native-slider', '../node_modules/@react-native-community/slider'
  add_pod_if_present 'RNDeviceInfo', '../node_modules/react-native-device-info'
  add_pod_if_present 'RNFS', '../node_modules/react-native-fs'
  add_pod_if_present 'react-native-blob-util', '../node_modules/react-native-blob-util'
  add_pod_if_present 'react-native-safe-area-context', '../node_modules/react-native-safe-area-context'
  add_pod_if_present 'react-native-restart', '../node_modules/react-native-restart'
  add_pod_if_present 'react-native-quick-base64', '../node_modules/react-native-quick-base64'
  add_pod_if_present 'react-native-get-random-values', '../node_modules/react-native-get-random-values'
  add_pod_if_present 'react-native-uuid', '../node_modules/react-native-uuid'
  add_pod_if_present 'react-native-mmkv', '../node_modules/react-native-mmkv'
  add_pod_if_present 'react-native-sqlite-storage', '../node_modules/react-native-sqlite-storage'
  add_pod_if_present 'react-native-music-control', '../node_modules/react-native-music-control'

end

post_install do |installer|
  react_native_post_install(installer)

  # Unconditionally disable I/O path analysis to avoid flaky .xcfilelist issues
  installer.pods_project.targets.each do |t|
    t.build_configurations.each do |c|
      c.build_settings['DISABLE_INPUT_OUTPUT_PATHS'] = 'YES'
      c.build_settings['CLANG_CXX_LANGUAGE_STANDARD'] = 'c++20'
      c.build_settings['CLANG_CXX_LIBRARY'] = 'libc++'
    end
  end

  # Remove obsolete Hermes phase if present (idempotent)
  hermes_phase_labels = ['[Hermes] Replace Hermes']
  remove_hermes_phase = lambda do |target, scope|
    return 0 unless target.respond_to?(:shell_script_build_phases)
    phases = target.shell_script_build_phases.select do |phase|
      phase_name = phase.respond_to?(:name) ? phase.name.to_s.strip : ''
      display_name =
        if phase.respond_to?(:display_name)
          phase.display_name.to_s.strip
        else
          phase_name
        end
      hermes_phase_labels.any? { |needle| display_name.include?(needle) }
    end
    removed = 0
    phases.each { |p| target.build_phases.delete(p); removed += 1 }
    removed
  end

  header_search_fix = '$(PODS_ROOT)/Headers/Public/RCTDeprecation'
  module_map_path = '$(PODS_ROOT)/Headers/Public/RCTDeprecation/module.modulemap'
  legacy_module_map_path = '$(PODS_ROOT)/Headers/Public/RCTDeprecation/RCTDeprecation.modulemap'
  module_map_flag = "-fmodule-map-file=#{module_map_path}"
  legacy_module_map_flag = "-fmodule-map-file=#{legacy_module_map_path}"
  legacy_module_map_flag_pattern = /(?<!\S)#{Regexp.escape(legacy_module_map_flag)}(?!\S)/
  legacy_module_map_path_pattern = /(?<!\S)#{Regexp.escape(legacy_module_map_path)}(?!\S)/
  legacy_module_map_flag_quoted_pattern = /"#{Regexp.escape(legacy_module_map_flag)}"/
  legacy_module_map_path_quoted_pattern = /"#{Regexp.escape(legacy_module_map_path)}"/
  # Provide a single canonical module map so clang never has to reconcile two
  # definitions of the same module. Previous builds shipped both
  # `module.modulemap` and `RCTDeprecation.modulemap`, which allowed the compiler
  # to load either file depending on discovery order. When a precompiled header
  # cached one path and the next build discovered the other, Xcode 16 aborted the
  # build because the AST referenced a different module map path. Keeping only the
  # canonical file and updating build settings to point at it ensures every
  # invocation resolves the module identically.
  module_map_flags = [module_map_flag].compact
  module_map_dir = File.join(installer.sandbox.root.to_s, 'Headers', 'Public', 'RCTDeprecation')
  module_map_disk = File.join(module_map_dir, 'module.modulemap')
  legacy_module_map_disk = File.join(module_map_dir, 'RCTDeprecation.modulemap')
  target_support_dir = File.join(installer.sandbox.root.to_s, 'Target Support Files', 'RCTDeprecation')
  target_support_module_map = File.join(target_support_dir, 'module.modulemap')
  legacy_target_support_module_map = File.join(target_support_dir, 'RCTDeprecation.modulemap')
  module_map_template = File.join(__dir__, 'Config', 'RCTDeprecation.modulemap')
  raise "Missing #{module_map_template}; ensure it is checked in" unless File.exist?(module_map_template)
  desired_module_map = File.read(module_map_template)

  FileUtils.mkdir_p(module_map_dir)
  existing_module_map = File.exist?(module_map_disk) ? File.read(module_map_disk) : nil
  if existing_module_map != desired_module_map
    Pod::UI.puts "[Podfile] Writing #{module_map_disk} (primary)"
    File.write(module_map_disk, desired_module_map)
  end

  if File.exist?(legacy_module_map_disk) || File.symlink?(legacy_module_map_disk)
    Pod::UI.puts "[Podfile] Removing legacy module map at #{legacy_module_map_disk}"
    FileUtils.rm_f(legacy_module_map_disk)
  end

  pods_project_modified = false
  installer.pods_project.targets.each do |target|
    removed = remove_hermes_phase.call(target, 'pods')
    if removed > 0
      Pod::UI.puts "[Podfile] Removed #{removed} legacy Hermes phases from #{target.name}"
      pods_project_modified = true
    end
  end

  installer.pods_project.targets.each do |target|
    target_name = target.respond_to?(:name) ? target.name.to_s : ''
    force_tokens = target_name == 'RCTDeprecation' || target_name.start_with?('Pods-')
    enforce_module_identity = target_name == 'RCTDeprecation'

    target.build_configurations.each do |config|
      updated = sanitize_module_map_settings(
        config,
        :header_search_fix => header_search_fix,
        :module_map_flags => module_map_flags,
        :module_map_path => module_map_path,
        :legacy_module_map_flag => legacy_module_map_flag,
        :force_tokens => force_tokens,
        :enforce_module_map => enforce_module_identity,
        :enforce_defines_module => enforce_module_identity
      )

      if updated
        Pod::UI.puts "[Podfile] Updated build settings for #{target.name} (#{config.name})"
        pods_project_modified = true
      end
    end
  end

  installer.pods_project.save if pods_project_modified
  installer.aggregate_targets.each do |aggregate_target|
    user_project = aggregate_target.user_project
    next unless user_project

    project_modified = false

    user_project.targets.each do |target|
      next unless target.name == 'monGARS'

      target.build_configurations.each do |config|
        removed_std = config.build_settings.delete('CLANG_CXX_LANGUAGE_STANDARD')
        if removed_std
          project_modified = true
          if removed_std != '$(inherited)'
            Pod::UI.puts "[Podfile] Clearing CLANG_CXX_LANGUAGE_STANDARD for #{target.name} (#{config.name})"
          end
        end

        current_library = config.build_settings['CLANG_CXX_LIBRARY']
        if current_library != 'libc++'
          config.build_settings['CLANG_CXX_LIBRARY'] = 'libc++'
          project_modified = true
        end

        updated = sanitize_module_map_settings(
          config,
          :header_search_fix => header_search_fix,
          :module_map_flags => module_map_flags,
          :module_map_path => module_map_path,
          :legacy_module_map_flag => legacy_module_map_flag,
          :force_tokens => true
        )

        project_modified ||= updated
      end
    end

    user_project.save if project_modified
  end

  support_files_root = File.join(__dir__, 'Pods', 'Target Support Files')
  if Dir.exist?(support_files_root)
    Dir.glob(File.join(support_files_root, '**', '*.xcconfig')).each do |xcconfig_path|
      original = File.read(xcconfig_path)
      replaced = original.gsub(legacy_module_map_flag_pattern, module_map_flag)
      replaced = replaced.gsub(legacy_module_map_path_pattern, module_map_path)
      replaced = replaced.gsub(legacy_module_map_flag_quoted_pattern, "\"#{module_map_flag}\"")
      replaced = replaced.gsub(legacy_module_map_path_quoted_pattern, "\"#{module_map_path}\"")

      next if replaced == original

      Pod::UI.puts "[Podfile] Updated #{xcconfig_path} to prefer module.modulemap"
      File.write(xcconfig_path, replaced)
    end
  end

  if Dir.exist?(target_support_dir)
    existing_target_support_map = File.exist?(target_support_module_map) ? File.read(target_support_module_map) : nil
    if existing_target_support_map != desired_module_map
      Pod::UI.puts "[Podfile] Writing #{target_support_module_map} (target support)"
      File.write(target_support_module_map, desired_module_map)
    end

    if File.exist?(legacy_target_support_module_map) || File.symlink?(legacy_target_support_module_map)
      Pod::UI.puts "[Podfile] Removing legacy module map at #{legacy_target_support_module_map}"
      FileUtils.rm_f(legacy_target_support_module_map)
    end
  end

  Dir.glob(File.join(installer.sandbox.root.to_s, '**', 'RCTDeprecation.modulemap')).each do |stray_module_map|
    Pod::UI.puts "[Podfile] Removing stray legacy module map at #{stray_module_map}"
    FileUtils.rm_f(stray_module_map)
  end

  purge_script = File.join(__dir__, 'scripts', 'purge-rctdeprecation-caches.sh')
  if File.exist?(purge_script)
    env = {
      'PROJECT_DIR' => __dir__,
      'APP_TARGET' => 'monGARS',
      'MODULE_NAME' => 'RCTDeprecation',
      'LEGACY_MODULE_MAP_NAME' => 'RCTDeprecation.modulemap'
    }

    stdout_str, stderr_str, status = Open3.capture3(env, 'bash', purge_script)

    stdout_str.each_line do |line|
      line = line.strip
      Pod::UI.puts("[Podfile] #{line}") unless line.empty?
    end

    stderr_str.each_line do |line|
      line = line.strip
      Pod::UI.warn("[Podfile] STDERR: #{line}") unless line.empty?
    end

    unless status.success?
      Pod::UI.warn('[Podfile] Failed to purge legacy RCTDeprecation caches; manual cleanup may be required.')
    end
  else
    Pod::UI.warn('[Podfile] Missing ios/scripts/purge-rctdeprecation-caches.sh; derived data may still reference legacy module maps.')
  end

  mlx_patch_script = File.join(__dir__, 'scripts', 'patch-mlx-metal-cxx17.sh')
  if File.exist?(mlx_patch_script)
    env = { 'PROJECT_DIR' => __dir__, 'SRCROOT' => __dir__ }
    stdout_str, stderr_str, status = Open3.capture3(env, 'bash', mlx_patch_script)

    stdout_str.each_line do |line|
      line = line.strip
      Pod::UI.puts("[Podfile] #{line}") unless line.empty?
    end

    unless status.success?
      stderr_str.each_line do |line|
        line = line.strip
        Pod::UI.warn("[Podfile] STDERR: #{line}") unless line.empty?
      end
      Pod::UI.warn('[Podfile] Failed to patch MLX metal headers; warnings may persist. ' \
                   'You can re-run ios/scripts/patch-mlx-metal-cxx17.sh manually.')
    end
  else
    Pod::UI.warn('[Podfile] Missing ios/scripts/patch-mlx-metal-cxx17.sh; MLX metal warnings may persist.')
  end

  # Try to apply RN Contacts orientation patch (if repo has the script)
  patch_script = File.join(__dir__, 'scripts', 'patch-react-native-contacts.sh')
  if File.exist?(patch_script)
    stdout_str, stderr_str, status = Open3.capture3('bash', patch_script)
    if !status.success?
      stdout_str.each_line { |line| Pod::UI.warn("[Podfile] STDOUT: #{line.strip}") unless line.strip.empty? }
      stderr_str.each_line { |line| Pod::UI.warn("[Podfile] STDERR: #{line.strip}") unless line.strip.empty? }
      Pod::UI.warn('[Podfile] Contacts patch failed (non-fatal). ' \
                   'This may be due to sandboxing or idempotency. Consider re-running the patch manually.')
    end
  else
    Pod::UI.warn('[Podfile] Missing ios/scripts/patch-react-native-contacts.sh; skipping contacts orientation patch.')
  end
end
