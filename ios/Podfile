# Ensure pods support iOS 18.0+; the app's deployment target lives in project.yml
platform :ios, '18.0'
ENV['RCT_NEW_ARCH_ENABLED'] = "1" # Enable Fabric/TurboModules

# Include React Native's CocoaPods helpers
require_relative '../node_modules/react-native/scripts/react_native_pods'

# --- Build hygiene for CI ---
install! 'cocoapods',
  :generate_multiple_pod_projects => true,
  :disable_input_output_paths => true,
  :warn_for_multiple_pod_sources => true

# --- Robust project discovery (handles subfolders like ios/MyOfflineLLMApp/*.xcodeproj)
project_candidates = Dir['*.xcodeproj'] + Dir['**/*.xcodeproj']
project_path = project_candidates.first
raise "No .xcodeproj found near Podfile (#{__dir__})" unless project_path
puts "Using Xcode project at: #{project_path}"

# Map build configurations so CocoaPods knows which are debug vs release
project project_path, 'Debug' => :debug, 'Release' => :release
app_target = File.basename(project_path, '.xcodeproj')

USE_FLIPPER = ENV['USE_FLIPPER'] == '1'
NEW_ARCH_ENABLED = ENV['RCT_NEW_ARCH_ENABLED'] == '1'

target app_target do
  use_frameworks! :linkage => :static

  config = (use_native_modules! rescue nil) || {}
  react_native_path = config[:reactNativePath] || File.expand_path('../node_modules/react-native', __dir__)

  use_react_native!(
    :path => react_native_path,
    :hermes_enabled => true,
    :new_arch_enabled => true,
    :fabric_enabled => NEW_ARCH_ENABLED,
    :app_path => "#{Pod::Config.instance.installation_root}/.."
  )

  # Headers for <react/bridging/*.h> (fixes TurboModule missing headers)
  pod 'ReactCommon/turbomodule/bridging', :path => "#{react_native_path}/ReactCommon"

  if USE_FLIPPER
    use_flipper!({ 'Flipper' => '0.203.0' })
  end
end

# ---- Hermes Fix 2: Remove "Replace Hermes" script phases everywhere ----
FORBIDDEN_HERMES_MARKERS = [
  'replace hermes',
  'replace hermes for the right configuration',
  '[hermes]'
].freeze

def strip_hermes_replacement_scripts!(project)
  project.targets.each do |t|
    t.build_phases
      .select do |p|
        p.isa == 'PBXShellScriptBuildPhase' &&
          FORBIDDEN_HERMES_MARKERS.any? do |m|
            (p.name || '').downcase.include?(m) ||
              (p.shell_script || '').downcase.include?(m)
          end
      end
      .each do |p|
        t.build_phases.delete(p)
        p.remove_from_project
      end
  end
  project.save
end

def pods_projects_for(installer)
  pods = [installer.pods_project]
  pods.concat(Array(installer.generated_projects)) if installer.respond_to?(:generated_projects)
  pods.compact
end

def user_projects_for(installer)
  installer.aggregate_targets.map(&:user_project).compact.uniq { |p| p.path.to_s }
end

# ---------- C++ header & flags normalization to fix <cstdint>/<stdint.h> mixups ----------
def normalize_cxx_for_target!(t)
  t.build_configurations.each do |cfg|
    bs = cfg.build_settings

    # Ensure libc++ (toolchain) headers come before SDK C headers
    header_paths = Array(bs['HEADER_SEARCH_PATHS']) + Array(bs['SYSTEM_HEADER_SEARCH_PATHS'])
    header_paths = header_paths.flatten.compact

    # Remove duplicates & sanitize
    header_paths = header_paths.reject { |p| p.to_s.strip.empty? }.uniq

    libcxx = '$(TOOLCHAIN_DIR)/usr/include/c++/v1'
    sdk_c  = '$(SDKROOT)/usr/include'

    # Remove any existing occurrences so we can re-add in correct order
    header_paths -= [libcxx, sdk_c]

    # Prepend libc++ then C headers
    header_paths = [libcxx, sdk_c] + header_paths

    bs['HEADER_SEARCH_PATHS'] = header_paths
    # Optional: also set SYSTEM_HEADER_SEARCH_PATHS to match
    bs['SYSTEM_HEADER_SEARCH_PATHS'] = header_paths

    # Standard & flags cleanup
    bs['CLANG_CXX_LANGUAGE_STANDARD'] = 'gnu++17'

    # Nuke problematic flags if present
    cppflags = Array(bs['OTHER_CPLUSPLUSFLAGS'])
    cppflags = cppflags.reject { |f| f =~ /-nostdinc\+\+/ || f =~ /-stdlib=/ }

    # Prepend explicit -isystem ordering to be extra safe
    cppflags = [
      '-isystem', libcxx,
      '-isystem', sdk_c
    ] + cppflags

    bs['OTHER_CPLUSPLUSFLAGS'] = cppflags
  end
end
# ----------------------------------------------------------------------------------------

post_install do |installer|
  react_native_post_install(installer) if defined?(react_native_post_install)

  # --- Safety: scrub CocoaPods [CP] phases I/O lists & minor build settings
  def scrub_cp_filelists_from_target(target)
    target.build_phases.each do |phase|
      next unless phase.respond_to?(:name)
      next unless phase.name&.include?('[CP]')
      begin
        phase.input_paths = [] if phase.respond_to?(:input_paths=)
        phase.output_paths = [] if phase.respond_to?(:output_paths=)
        phase.input_file_list_paths = [] if phase.respond_to?(:input_file_list_paths=)
        phase.output_file_list_paths = [] if phase.respond_to?(:output_file_list_paths=)
      rescue => e
        puts "WARN: Skipping scrub for phase #{phase.name}: #{e}"
      end
    end
  end

  pods_projects = pods_projects_for(installer)
  user_projects = user_projects_for(installer)
  all_projects = (pods_projects + user_projects).uniq { |p| p.path.to_s }

  all_projects.each do |proj|
    proj.targets.each do |t|
      scrub_cp_filelists_from_target(t)
      # ðŸ”§ Fix header search order & C++ flags
      normalize_cxx_for_target!(t)

      t.build_configurations.each do |cfg|
        cfg.build_settings['ENABLE_USER_SCRIPT_SANDBOXING'] = 'NO'
        if cfg.name.include?('Debug')
          cfg.build_settings['SWIFT_OPTIMIZATION_LEVEL'] = '-Onone'
          cfg.build_settings['SWIFT_COMPILATION_MODE'] = 'singlefile'
        else
          cfg.build_settings['SWIFT_OPTIMIZATION_LEVEL'] ||= '-O'
        end
        cfg.build_settings['SWIFT_VERSION'] ||= '5.0'
        # Bump any low deployment targets
        min_target = Gem::Version.new('18.0')
        current = Gem::Version.new(cfg.build_settings['IPHONEOS_DEPLOYMENT_TARGET'] || '0')
        cfg.build_settings['IPHONEOS_DEPLOYMENT_TARGET'] = min_target.to_s if current < min_target
        cfg.build_settings['USE_HEADERMAP'] = 'YES'
        cfg.build_settings['ALWAYS_SEARCH_USER_PATHS'] = 'NO'
      end
    end
    proj.save
  end

  # Remove Hermes "Replace Hermes" scripts
  all_projects.each { |proj| strip_hermes_replacement_scripts!(proj) }

  # Mark [CP] phases (no I/O) as always out-of-date to silence warnings
  all_projects.each do |proj|
    proj.targets.each do |t|
      t.build_phases
        .select { |p| p.isa == 'PBXShellScriptBuildPhase' && p.name&.start_with?('[CP]') }
        .each { |run| run.always_out_of_date = '1' if (run.input_paths || []).empty? && (run.output_paths || []).empty? }
    end
    proj.save
  end
end

post_integrate do |installer|
  pods_projects = pods_projects_for(installer)
  user_projects = user_projects_for(installer)

  # Re-strip Hermes scripts if any got reintroduced
  (pods_projects + user_projects).each { |proj| strip_hermes_replacement_scripts!(proj) }

  # Mark [CP] phases (no I/O) as always out-of-date
  (pods_projects + user_projects).each do |proj|
    proj.targets.each do |t|
      t.build_phases
        .select { |p| p.isa == 'PBXShellScriptBuildPhase' && p.name&.start_with?('[CP]') }
        .each { |run| run.always_out_of_date = '1' if (run.input_paths || []).empty? && (run.output_paths || []).empty? }
    end
    proj.save
  end

  # CI guard for Hermes script presence (optional)
  if ENV['CI']
    offending = []
    (pods_projects + user_projects).each do |proj|
      proj.targets.each do |t|
        t.build_phases.select { |p| p.isa == 'PBXShellScriptBuildPhase' }.each do |phase|
          name = (phase.name || '').downcase
          body = (phase.shell_script || '').downcase
          if FORBIDDEN_HERMES_MARKERS.any? { |m| name.include?(m) || body.include?(m) }
            offending << "#{proj.path.basename} :: #{t.name} :: #{phase.name}"
          end
        end
      end
    end
    unless offending.empty?
      raise <<~MSG
        Detected forbidden Hermes script phase(s):
          #{offending.join("\n  ")}
        CI policy: the "[Hermes] Replace Hermes" script must not exist after pod install.
      MSG
    end
  end
end
