# Ensure the platform is set to iOS 18.0
platform :ios, '18.0'
ENV['RCT_NEW_ARCH_ENABLED'] = "1" # Enable Fabric/TurboModules

# Include React Native's CocoaPods helpers
require_relative '../node_modules/react-native/scripts/react_native_pods'

# --- Build hygiene for CI ---
install! 'cocoapods',
  :generate_multiple_pod_projects => true,
  # Disable file lists since we statically link pods; avoids missing .xcfilelist lookups on CI
  :disable_input_output_paths => true,
  :warn_for_multiple_pod_sources => true
# --- Robust project discovery (handles subfolders like ios/MyOfflineLLMApp/*.xcodeproj)
project_candidates = Dir['*.xcodeproj'] + Dir['**/*.xcodeproj']
project_path = project_candidates.first
raise "No .xcodeproj found near Podfile (#{__dir__})" unless project_path
puts "Using Xcode project at: #{project_path}"

# Map build configurations so CocoaPods knows which are debug vs release
project project_path, 'Debug' => :debug, 'Release' => :release
app_target = File.basename(project_path, '.xcodeproj')

USE_FLIPPER = ENV['USE_FLIPPER'] == '1'
NEW_ARCH_ENABLED = ENV['RCT_NEW_ARCH_ENABLED'] == '1'

target app_target do
  use_frameworks! :linkage => :static

  config = (use_native_modules! rescue nil) || {}
  react_native_path = config[:reactNativePath] || File.expand_path('../node_modules/react-native', __dir__)

  use_react_native!(
    :path => react_native_path,
    :hermes_enabled => true,
    :new_arch_enabled => true,
    :fabric_enabled => NEW_ARCH_ENABLED,
    :app_path => "#{Pod::Config.instance.installation_root}/.."
  )

  # Ensure TurboModule core can find bridging headers like EventEmitter.h
  pod 'ReactCommon/turbomodule/bridging',
      :path => "#{react_native_path}/ReactCommon" # exposes <react/bridging/...> to TurboModule core

  # Codegen pods (ReactCodegen + ReactAppDependencyProvider) are handled automatically by use_react_native! using :app_path

  if USE_FLIPPER
    use_flipper!({ 'Flipper' => '0.203.0' })
  end

end

post_install do |installer|
  react_native_post_install(installer) if defined?(react_native_post_install)

  # --- Safety: with static Pods, scrub any input/output file lists CocoaPods might add
  # This prevents Xcode from expecting *.xcfilelist even if some scripts re-introduce them.
  # Applies to both the Pods project and the user app project.
  def scrub_cp_filelists_from_target(target)
    target.build_phases.each do |phase|
      next unless phase.respond_to?(:name)
      next unless phase.name&.include?('[CP]')
      begin
        phase.input_paths = [] if phase.respond_to?(:input_paths=)
        phase.output_paths = [] if phase.respond_to?(:output_paths=)
      rescue => e
        puts "WARN: Skipping scrub for phase #{phase.name}: #{e}"
      end
    end
  end

  # Pods project
  installer.pods_project.targets.each do |t|
    scrub_cp_filelists_from_target(t)
    t.build_configurations.each do |cfg|
      cfg.build_settings['ENABLE_USER_SCRIPT_SANDBOXING'] = 'NO'
      if cfg.name.include?('Debug')
        # SwiftUI previews expect no optimization in debug builds
        cfg.build_settings['SWIFT_OPTIMIZATION_LEVEL'] = '-Onone'
        cfg.build_settings['SWIFT_COMPILATION_MODE'] = 'singlefile'
      else
        cfg.build_settings['SWIFT_OPTIMIZATION_LEVEL'] ||= '-O'
      end

      # Ensure mixed C++ headers compile under gnu++17 and Swift 5
      cfg.build_settings['CLANG_CXX_LANGUAGE_STANDARD'] ||= 'gnu++17'
      cfg.build_settings['SWIFT_VERSION'] ||= '5.0'

      # Bump pods below iOS 13 to avoid deployment target warnings
      min = Gem::Version.new('13.0')
      cur = Gem::Version.new((cfg.build_settings['IPHONEOS_DEPLOYMENT_TARGET'] || '0.0').to_s)
      cfg.build_settings['IPHONEOS_DEPLOYMENT_TARGET'] = '13.0' if cur < min

      # ReactCommon's TurboModule core needs bridging headers like <react/bridging/EventEmitter.h>
      if t.name == 'ReactCommon'
        cfg.build_settings['HEADER_SEARCH_PATHS'] ||= '$(inherited)'
        cfg.build_settings['HEADER_SEARCH_PATHS'] << ' "$(PODS_ROOT)/Headers/Public/ReactCommon"'
      end
    end
  end

  # User (app) project(s)
  installer.aggregate_targets.each do |agg|
    user_project = agg.user_project
    user_project.targets.each do |t|
      scrub_cp_filelists_from_target(t)
      t.build_configurations.each do |cfg|
        cfg.build_settings['ENABLE_USER_SCRIPT_SANDBOXING'] = 'NO'
      end
    end
    user_project.save
  end

  installer.pods_project.save
end

 # Silences "will be run during every build" warnings for shell phases with no I/O,
 # and scrubs any Hermes "Replace Hermes" phases that may be (re)introduced.
 post_integrate do |installer|
  pods_projects =
    if installer.respond_to?(:generated_projects) && installer.generated_projects.any?
      installer.generated_projects.select { |p| p.path.basename.to_s.include?('Pods') }
    else
      [installer.pods_project].compact
    end

  # --- Remove the forbidden Hermes script from ALL Pods projects (CI only)
  if ENV['CI'] == 'true'
    pods_projects.each do |proj|
      proj.targets.each do |t|
        next unless t.name == 'hermes-engine'
        t.shell_script_build_phases.each do |phase|
          if phase.name&.include?('Replace Hermes for the right configuration')
            t.build_phases.delete(phase)
          end
        end
      end
      proj.save
    end
  end

  # --- Collect real Xcode *projects* only (avoid Pod::PodTarget, etc.)
  user_projects = installer.aggregate_targets
    .select { |agg| agg.respond_to?(:user_project) && agg.user_project }
    .map(&:user_project)
    .uniq { |p| p.path.to_s }

  # Mark [CP] phases without I/O as always out-of-date to silence Xcode warnings
  (pods_projects + user_projects).each do |proj|
    proj.targets.each do |t|
      t.build_phases
        .select { |p| p.isa == 'PBXShellScriptBuildPhase' && p.name&.start_with?('[CP]') }
        .each do |run|
          run.always_out_of_date = '1' if (run.input_paths || []).empty? && (run.output_paths || []).empty?
        end
    end
    proj.save
  end

  # --- Guard: fail if any Hermes replacement script remains in any Pods project
  if ENV['CI'] == 'true'
    offending = []
    pods_projects.each do |proj|
      proj.targets.each do |t|
        next unless t.name == 'hermes-engine'
        t.shell_script_build_phases.each do |phase|
          name = (phase.name || '').downcase
          body = (phase.shell_script || '').downcase
          offending << "#{proj.path} :: #{t.name} :: #{phase.name}" if name.include?('replace hermes') || body.include?('replace hermes')
        end
      end
    end
    unless offending.empty?
      raise <<~MSG
        Detected forbidden Hermes script phase(s):
          #{offending.join("\n  ")}
        CI policy: the "[Hermes] Replace Hermes" script must not exist after pod install.
      MSG
    end
  end
end
