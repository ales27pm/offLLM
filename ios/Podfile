# Ensure pods support iOS 18.0+ (app's actual deployment target is set in Xcode project)
platform :ios, '18.0'
ENV['RCT_NEW_ARCH_ENABLED'] = "1"  # Enable Fabric/TurboModules for New Architecture

# Include React Native CocoaPods helpers
require_relative '../node_modules/react-native/scripts/react_native_pods'
require_relative '../node_modules/react-native/scripts/react_native_post_install'  # Ensure RN post_install is available

# CocoaPods installation settings for CI stability
install! 'cocoapods',
  generate_multiple_pod_projects: true,
  disable_input_output_paths: true,       # Do not generate .xcfilelist files (avoid missing file issues on CI)
  warn_for_multiple_pod_sources: true

# Find the Xcode project (handles Xcodegen output in subfolder)
project_candidates = Dir['*.xcodeproj'] + Dir['**/*.xcodeproj']
project_path = project_candidates.first or raise "No .xcodeproj found near Podfile (#{__dir__})"
puts "Using Xcode project at: #{project_path}"
project project_path, 'Debug' => :debug, 'Release' => :release  # Map configuration names

app_target = File.basename(project_path, '.xcodeproj')
USE_FLIPPER = ENV['USE_FLIPPER'] == '1'
NEW_ARCH_ENABLED = ENV['RCT_NEW_ARCH_ENABLED'] == '1'

target app_target do
  use_frameworks! :linkage => :static
  config = (use_native_modules! rescue nil) || {}  # Auto-link React Native modules
  react_native_path = config[:reactNativePath] || File.expand_path('../node_modules/react-native', __dir__)

  use_react_native!(
    path: react_native_path,
    hermes_enabled: true,
    fabric_enabled: NEW_ARCH_ENABLED,   # Enable Fabric if new architecture is on
    new_arch_enabled: true,             # Use new architecture (TurboModules) project setup
    app_path: "#{Pod::Config.instance.installation_root}/.."
  )

  # (Optional) Add any extra pods here, e.g. custom ones not covered by auto-linking.
  # pod 'SomeLibrary', :path => '../node_modules/some-library'
end

# Post-installation tweaks to fix build issues and warnings
post_install do |installer|
  react_native_post_install(installer) if defined?(react_native_post_install)

  # 1. Disable any CocoaPods script input/output file lists (already disabled above, but double-check in generated projects)
  def scrub_cp_filelists_from_target(target)
    target.build_phases.each do |phase|
      next unless phase.respond_to?(:name) && phase.name.to_s.start_with?('[CP]')
      # Remove file lists and paths to avoid missing file warnings
      phase.input_paths = [] if phase.respond_to?(:input_paths=)
      phase.output_paths = [] if phase.respond_to?(:output_paths=)
      phase.input_file_list_paths = [] if phase.respond_to?(:input_file_list_paths=)
      phase.output_file_list_paths = [] if phase.respond_to?(:output_file_list_paths=)
    rescue => e
      puts "WARN: Could not scrub file lists for phase #{phase.name}: #{e}"
    end
  end

  # Helper to get all project objects (Pods project + any user projects)
  pods_projects = [installer.pods_project] + (installer.respond_to?(:generated_projects) ? installer.generated_projects : [])
  user_projects = installer.aggregate_targets.map(&:user_project).compact.uniq { |p| p.path.to_s }
  all_projects = (pods_projects + user_projects).compact.uniq { |p| p.path.to_s }

  all_projects.each do |project|
    # Iterate over each target in each project
    project.targets.each do |target|
      # Scrub CocoaPods filelist settings
      scrub_cp_filelists_from_target(target)

      target.build_configurations.each do |cfg|
        # Disable script sandboxing for all targets (to allow [CP] scripts to modify files freely)
        cfg.build_settings['ENABLE_USER_SCRIPT_SANDBOXING'] = 'NO'
        if cfg.name.include?('Debug')
          # Debug builds – no optimization for Swift (needed for SwiftUI Previews)
          cfg.build_settings['SWIFT_OPTIMIZATION_LEVEL'] = '-Onone'
          cfg.build_settings['SWIFT_COMPILATION_MODE'] = 'singlefile'
        else
          # Release builds – ensure optimization is enabled (if not already)
          cfg.build_settings['SWIFT_OPTIMIZATION_LEVEL'] ||= '-O'
        end
        # If target contains Swift sources, enforce Swift 5 (if not already specified)
        has_swift_sources = target.source_build_phase.files.any? { |f| f.file_ref.path.end_with?('.swift') rescue false }
        if has_swift_sources
          cfg.build_settings['SWIFT_VERSION'] ||= '5.0'
        end
        # Bump deployment target to at least iOS 18.0 for all pods to avoid warnings
        min_ios = Gem::Version.new('18.0')
        curr_target = Gem::Version.new(cfg.build_settings['IPHONEOS_DEPLOYMENT_TARGET'] || '0')
        if curr_target < min_ios
          cfg.build_settings['IPHONEOS_DEPLOYMENT_TARGET'] = '18.0'
        end
        # Ensure modern C++ standard for RN new architecture bridging code
        cfg.build_settings['CLANG_CXX_LANGUAGE_STANDARD'] ||= 'gnu++17'
        cfg.build_settings['ALWAYS_SEARCH_USER_PATHS'] = 'NO'
      end

      # Remove any Hermes “Replace Hermes” shell script phases that might exist
      target.shell_script_build_phases.each do |phase|
        phase_name = phase.name.to_s
        if phase_name.include?('Replace Hermes')
          puts "Removing script phase '#{phase_name}' from target #{target.name}"
          target.build_phases.delete(phase)
        end
      end

      # Mark [CP] phases without I/O as always out-of-date to avoid Xcode warnings
      target.shell_script_build_phases.each do |phase|
        if phase.name.to_s.start_with?('[CP]') 
          ioEmpty = (phase.respond_to?(:input_paths) && phase.input_paths.to_a.empty?) && 
                    (phase.respond_to?(:output_paths) && phase.output_paths.to_a.empty?)
          phase.always_out_of_date = '1' if ioEmpty && phase.respond_to?(:always_out_of_date=)
        end
      end
    end
    project.save
  end
end