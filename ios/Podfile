# frozen_string_literal: true

platform :ios, '18.0'
ENV['RCT_NEW_ARCH_ENABLED'] = '1'
USE_FLIPPER = (ENV['USE_FLIPPER'] == '1')

require_relative '../node_modules/react-native/scripts/react_native_pods'

project_candidates = Dir['*.xcodeproj'] + Dir['**/*.xcodeproj']
project_path = project_candidates.first
raise "No .xcodeproj found near Podfile (#{__dir__})" unless project_path
puts "Using Xcode project at: #{project_path}"
project project_path, 'Debug' => :debug, 'Release' => :release
app_target = File.basename(project_path, '.xcodeproj')

NEW_ARCH_ENABLED = (ENV['RCT_NEW_ARCH_ENABLED'] == '1')

target app_target do
  use_frameworks! linkage: :static

  config = (use_native_modules! rescue {}) || {}
  react_native_path = config[:reactNativePath] || File.expand_path('../node_modules/react-native', __dir__)

  use_react_native!(
    path: react_native_path,
    hermes_enabled: true,
    new_arch_enabled: true,
    fabric_enabled: NEW_ARCH_ENABLED,
    app_path: "#{Pod::Config.instance.installation_root}/.."
  )

  # Ensure bridging headers exist for TurboModules (fixes EventEmitter.h not found)
  pod 'ReactCommon/turbomodule/bridging', :path => "#{react_native_path}/ReactCommon"

  if USE_FLIPPER
    use_flipper!({ 'Flipper' => '0.203.0' })
  end
end

FORBIDDEN_HERMES_MARKERS = [
  'replace hermes',
  'replace hermes for the right configuration',
  '[hermes]'
].freeze

def strip_hermes_replacement_scripts!(project)
  project.targets.each do |t|
    t.build_phases
     .select { |p|
       p.isa == 'PBXShellScriptBuildPhase' &&
       FORBIDDEN_HERMES_MARKERS.any? { |m|
         (p.name || '').downcase.include?(m) || (p.shell_script || '').downcase.include?(m)
       }
     }
     .each do |p|
       t.build_phases.delete(p)
       p.remove_from_project
     end
  end
  project.save
end

def pods_projects_for(installer)
  pods = [installer.pods_project]
  pods.concat(Array(installer.generated_projects)) if installer.respond_to?(:generated_projects)
  pods.compact
end

def user_projects_for(installer)
  installer.aggregate_targets.map(&:user_project).compact.uniq { |p| p.path.to_s }
end

def sanitize_search_paths!(cfg)
  # 1) Keep inherited
  hsp = Array(cfg.build_settings['HEADER_SEARCH_PATHS']).map(&:to_s)
  lsp = Array(cfg.build_settings['LIBRARY_SEARCH_PATHS']).map(&:to_s)

  hsp = ['$(inherited)'] if hsp.empty?
  lsp = ['$(inherited)'] if lsp.empty?

  # 2) Remove dangerous entries that break libc++ include order
  bad_header_patterns = [
    %r{\A/usr/include}i,
    %r{\A\$\(?SDKROOT\)?/usr/include}i,
    %r{Xcode.*?/usr/include}i,
  ]
  hsp.reject! { |p| bad_header_patterns.any? { |rx| p =~ rx } }

  # 3) Make unique & store back
  cfg.build_settings['HEADER_SEARCH_PATHS']  = hsp.uniq
  cfg.build_settings['LIBRARY_SEARCH_PATHS'] = lsp.uniq

  # Toolchain/coompiler sanity
  cfg.build_settings['CLANG_CXX_LIBRARY']              = 'libc++'
  cfg.build_settings['CLANG_CXX_LANGUAGE_STANDARD']  ||= 'gnu++17'
  cfg.build_settings['SWIFT_VERSION']                ||= '5.0'
  cfg.build_settings['USE_HEADERMAP']                 = 'YES'
  cfg.build_settings['ALWAYS_SEARCH_USER_PATHS']      = 'NO'
end

def scrub_cp_filelists_from_target(target)
  target.build_phases.each do |phase|
    next unless phase.respond_to?(:name)
    next unless phase.name&.include?('[CP]')
    begin
      phase.input_paths = [] if phase.respond_to?(:input_paths=)
      phase.output_paths = [] if phase.respond_to?(:output_paths=)
      phase.input_file_list_paths = [] if phase.respond_to?(:input_file_list_paths=)
      phase.output_file_list_paths = [] if phase.respond_to?(:output_file_list_paths=)
    rescue => e
      puts "WARN: Skipping scrub for phase #{phase.name}: #{e}"
    end
  end
end

post_install do |installer|
  react_native_post_install(installer) if defined?(react_native_post_install)

  pods_projects = pods_projects_for(installer)
  user_projects = user_projects_for(installer)
  all_projects = (pods_projects + user_projects).uniq { |p| p.path.to_s }

  all_projects.each do |proj|
    proj.targets.each do |t|
      scrub_cp_filelists_from_target(t)
      t.build_configurations.each do |cfg|
        # Debug previews
        if cfg.name.include?('Debug')
          cfg.build_settings['SWIFT_OPTIMIZATION_LEVEL'] = '-Onone'
          cfg.build_settings['SWIFT_COMPILATION_MODE'] = 'singlefile'
        else
          cfg.build_settings['SWIFT_OPTIMIZATION_LEVEL'] ||= '-O'
        end

        # Minimum deployment
        min = Gem::Version.new('18.0')
        cur = Gem::Version.new(cfg.build_settings['IPHONEOS_DEPLOYMENT_TARGET'] || '0')
        cfg.build_settings['IPHONEOS_DEPLOYMENT_TARGET'] = min.to_s if cur < min

        sanitize_search_paths!(cfg)
      end
    end
    proj.save
  end

  # Remove forbidden Hermes phases
  all_projects.each { |proj| strip_hermes_replacement_scripts!(proj) }

  # Silence “will be run every build” warnings for [CP] phases that have no I/O
  all_projects.each do |proj|
    proj.targets.each do |t|
      t.build_phases
       .select { |p| p.isa == 'PBXShellScriptBuildPhase' && p.name&.start_with?('[CP]') }
       .each { |run|
         run.always_out_of_date = '1' if (run.input_paths || []).empty? && (run.output_paths || []).empty?
       }
    end
    proj.save
  end
end

post_integrate do |installer|
  (pods_projects_for(installer) + user_projects_for(installer)).each { |proj| strip_hermes_replacement_scripts!(proj) }
end
