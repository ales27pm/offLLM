# frozen_string_literal: true

# Full post-install hook: Clean duplicates, enforce single blueprint per spec
module PostInstallHardeningHook
  module_function

  def apply(installer)
    installer.pods_project.targets.each do |target|
      fix_codegen_duplicates(target.name, target)
    end
  end

  def fix_codegen_duplicates(pod_name, target)
    # Remove duplicate JSI specs generated by codegen when a manual stub exists.
    if duplicate_prone_pod?(pod_name)
      generated_dirs_for(target).each do |generated_dir|
        Dir.glob(File.join(generated_dir, '**', '*JSI-generated.*')).each do |file|
          manual_stub = file.sub('-generated', '')
          next unless File.exist?(manual_stub)

          File.delete(file)
          puts "Cleaned duplicate: #{file}"
        end
      end
    end

    # Enforce single AppSpec provider definitions for the main monGARS target.
    return unless target.name == 'monGARS'

    target.build_configurations.each do |config|
      definitions = normalize_definitions(config.build_settings['GCC_PREPROCESSOR_DEFINITIONS'])

      ensure_definition(definitions, '$(inherited)')
      ensure_definition(definitions, 'RCT_NEW_ARCH_ENABLED=1')
      ensure_definition(definitions, 'DISABLE_INPUT_OUTPUT_PATHS=YES')

      config.build_settings['GCC_PREPROCESSOR_DEFINITIONS'] = definitions
    end
  end

  def duplicate_prone_pod?(pod_name)
    pod_name == 'React-Codegen' || pod_name == 'ReactCommon' || pod_name.include?('hermes-engine')
  end

  def generated_dirs_for(target)
    root = Pod::Config.instance.installation_root
    candidate_paths = [
      File.expand_path(File.join('build', 'generated', 'ios'), root),
      File.expand_path(File.join(target.name, 'build', 'generated', 'ios'), root)
    ]

    candidate_paths.uniq.select { |path| Dir.exist?(path) }
  end

  def normalize_definitions(value)
    flattened =
      case value
      when nil
        []
      when Array
        value.flat_map { |entry| entry.to_s.split(/\s+/) }
      else
        value.to_s.split(/\s+/)
      end

    flattened.reject!(&:empty?)
    flattened
  end

  def ensure_definition(definitions, value)
    definitions << value unless definitions.include?(value)
  end
end
