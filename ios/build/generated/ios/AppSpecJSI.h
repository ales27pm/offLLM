/**
 * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
 *
 * Do not edit this file as changes may cause incorrect behavior and will be lost
 * once the code is regenerated.
 *
 * @generated by codegen project: GenerateModuleH.js
 */

#pragma once

#include <ReactCommon/TurboModule.h>
#include <react/bridging/Bridging.h>

namespace facebook::react {


  
#pragma mark - NativeLLMGenerateOptions

template <typename P0, typename P1, typename P2, typename P3, typename P4>
struct NativeLLMGenerateOptions {
  P0 maxTokens;
  P1 temperature;
  P2 topK;
  P3 topP;
  P4 stop;
  bool operator==(const NativeLLMGenerateOptions &other) const {
    return maxTokens == other.maxTokens && temperature == other.temperature && topK == other.topK && topP == other.topP && stop == other.stop;
  }
};

template <typename T>
struct NativeLLMGenerateOptionsBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.maxTokens)>(rt, value.getProperty(rt, "maxTokens"), jsInvoker),
      bridging::fromJs<decltype(types.temperature)>(rt, value.getProperty(rt, "temperature"), jsInvoker),
      bridging::fromJs<decltype(types.topK)>(rt, value.getProperty(rt, "topK"), jsInvoker),
      bridging::fromJs<decltype(types.topP)>(rt, value.getProperty(rt, "topP"), jsInvoker),
      bridging::fromJs<decltype(types.stop)>(rt, value.getProperty(rt, "stop"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static double maxTokensToJs(jsi::Runtime &rt, decltype(types.maxTokens) value) {
    return bridging::toJs(rt, value);
  }

  static double temperatureToJs(jsi::Runtime &rt, decltype(types.temperature) value) {
    return bridging::toJs(rt, value);
  }

  static double topKToJs(jsi::Runtime &rt, decltype(types.topK) value) {
    return bridging::toJs(rt, value);
  }

  static double topPToJs(jsi::Runtime &rt, decltype(types.topP) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<jsi::Array> stopToJs(jsi::Runtime &rt, decltype(types.stop) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    if (value.maxTokens) {
      result.setProperty(rt, "maxTokens", bridging::toJs(rt, value.maxTokens.value(), jsInvoker));
    }
    if (value.temperature) {
      result.setProperty(rt, "temperature", bridging::toJs(rt, value.temperature.value(), jsInvoker));
    }
    if (value.topK) {
      result.setProperty(rt, "topK", bridging::toJs(rt, value.topK.value(), jsInvoker));
    }
    if (value.topP) {
      result.setProperty(rt, "topP", bridging::toJs(rt, value.topP.value(), jsInvoker));
    }
    if (value.stop) {
      result.setProperty(rt, "stop", bridging::toJs(rt, value.stop.value(), jsInvoker));
    }
    return result;
  }
};



#pragma mark - NativeLLMLoadOptions

template <typename P0, typename P1>
struct NativeLLMLoadOptions {
  P0 quantization;
  P1 contextLength;
  bool operator==(const NativeLLMLoadOptions &other) const {
    return quantization == other.quantization && contextLength == other.contextLength;
  }
};

template <typename T>
struct NativeLLMLoadOptionsBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.quantization)>(rt, value.getProperty(rt, "quantization"), jsInvoker),
      bridging::fromJs<decltype(types.contextLength)>(rt, value.getProperty(rt, "contextLength"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static std::optional<jsi::String> quantizationToJs(jsi::Runtime &rt, decltype(types.quantization) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<double> contextLengthToJs(jsi::Runtime &rt, decltype(types.contextLength) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    if (value.quantization) {
      result.setProperty(rt, "quantization", bridging::toJs(rt, value.quantization.value(), jsInvoker));
    }
    if (value.contextLength) {
      result.setProperty(rt, "contextLength", bridging::toJs(rt, value.contextLength.value(), jsInvoker));
    }
    return result;
  }
};



#pragma mark - NativeLLMPerfMetrics

template <typename P0, typename P1>
struct NativeLLMPerfMetrics {
  P0 memoryUsage;
  P1 cpuUsage;
  bool operator==(const NativeLLMPerfMetrics &other) const {
    return memoryUsage == other.memoryUsage && cpuUsage == other.cpuUsage;
  }
};

template <typename T>
struct NativeLLMPerfMetricsBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.memoryUsage)>(rt, value.getProperty(rt, "memoryUsage"), jsInvoker),
      bridging::fromJs<decltype(types.cpuUsage)>(rt, value.getProperty(rt, "cpuUsage"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static double memoryUsageToJs(jsi::Runtime &rt, decltype(types.memoryUsage) value) {
    return bridging::toJs(rt, value);
  }

  static double cpuUsageToJs(jsi::Runtime &rt, decltype(types.cpuUsage) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    if (value.memoryUsage) {
      result.setProperty(rt, "memoryUsage", bridging::toJs(rt, value.memoryUsage.value(), jsInvoker));
    }
    if (value.cpuUsage) {
      result.setProperty(rt, "cpuUsage", bridging::toJs(rt, value.cpuUsage.value(), jsInvoker));
    }
    return result;
  }
};

class JSI_EXPORT NativeLLMCxxSpecJSI : public TurboModule {
protected:
  NativeLLMCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Value loadModel(jsi::Runtime &rt, jsi::String _path, std::optional<jsi::Object> _options) = 0;
  virtual jsi::Value unloadModel(jsi::Runtime &rt) = 0;
  virtual jsi::Value generate(jsi::Runtime &rt, jsi::String _prompt, std::optional<jsi::Object> _options) = 0;
  virtual jsi::Value embed(jsi::Runtime &rt, jsi::String _text) = 0;
  virtual jsi::Value getPerformanceMetrics(jsi::Runtime &rt) = 0;
  virtual jsi::Value getKVCacheSize(jsi::Runtime &rt) = 0;
  virtual jsi::Value getKVCacheMaxSize(jsi::Runtime &rt) = 0;
  virtual jsi::Value clearKVCache(jsi::Runtime &rt) = 0;
  virtual jsi::Value addMessageBoundary(jsi::Runtime &rt) = 0;
  virtual jsi::Value adjustPerformanceMode(jsi::Runtime &rt, jsi::String _mode) = 0;

};

template <typename T>
class JSI_EXPORT NativeLLMCxxSpec : public TurboModule {
public:
  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.create(rt, propName);
  }

  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
    return delegate_.getPropertyNames(runtime);
  }

  static constexpr std::string_view kModuleName = "LLM";

protected:
  NativeLLMCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeLLMCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}


private:
  class Delegate : public NativeLLMCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeLLMCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {

    }

    jsi::Value loadModel(jsi::Runtime &rt, jsi::String _path, std::optional<jsi::Object> _options) override {
      static_assert(
          bridging::getParameterCount(&T::loadModel) == 3,
          "Expected loadModel(...) to have 3 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::loadModel, jsInvoker_, instance_, std::move(_path), std::move(_options));
    }
    jsi::Value unloadModel(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::unloadModel) == 1,
          "Expected unloadModel(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::unloadModel, jsInvoker_, instance_);
    }
    jsi::Value generate(jsi::Runtime &rt, jsi::String _prompt, std::optional<jsi::Object> _options) override {
      static_assert(
          bridging::getParameterCount(&T::generate) == 3,
          "Expected generate(...) to have 3 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::generate, jsInvoker_, instance_, std::move(_prompt), std::move(_options));
    }
    jsi::Value embed(jsi::Runtime &rt, jsi::String _text) override {
      static_assert(
          bridging::getParameterCount(&T::embed) == 2,
          "Expected embed(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::embed, jsInvoker_, instance_, std::move(_text));
    }
    jsi::Value getPerformanceMetrics(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getPerformanceMetrics) == 1,
          "Expected getPerformanceMetrics(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getPerformanceMetrics, jsInvoker_, instance_);
    }
    jsi::Value getKVCacheSize(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getKVCacheSize) == 1,
          "Expected getKVCacheSize(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getKVCacheSize, jsInvoker_, instance_);
    }
    jsi::Value getKVCacheMaxSize(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getKVCacheMaxSize) == 1,
          "Expected getKVCacheMaxSize(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getKVCacheMaxSize, jsInvoker_, instance_);
    }
    jsi::Value clearKVCache(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::clearKVCache) == 1,
          "Expected clearKVCache(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::clearKVCache, jsInvoker_, instance_);
    }
    jsi::Value addMessageBoundary(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::addMessageBoundary) == 1,
          "Expected addMessageBoundary(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::addMessageBoundary, jsInvoker_, instance_);
    }
    jsi::Value adjustPerformanceMode(jsi::Runtime &rt, jsi::String _mode) override {
      static_assert(
          bridging::getParameterCount(&T::adjustPerformanceMode) == 2,
          "Expected adjustPerformanceMode(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::adjustPerformanceMode, jsInvoker_, instance_, std::move(_mode));
    }

  private:
    friend class NativeLLMCxxSpec;
    T *instance_;
  };

  Delegate delegate_;
};

} // namespace facebook::react
